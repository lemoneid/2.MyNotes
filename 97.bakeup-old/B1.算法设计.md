---
id : B1.算法设计
title : B1.算法设计
typora-root-url : ../
---



#  算法设计



# 算法

**算法**:对于一定规范的输入,具有明确定义的规则，能在有限时间内获得要求的输出

算法设计(策略)要不懈努力,反复修正



#### 算法的分类

1. 按求解问题的类型分组
2. 按算法内在的设计技术分组

精确算法:

近似算法:平方根,解非线性方程,求定积分



#### 算法的表示

1. 流程图
2. 伪代码
   - for while if
   - <- 赋值
   - // 注释

3. code



# 算法效率分析

### 算法效率

1. 时间复杂度:用输入规模的函数来度量
2. 空间复杂度:额外空间
3. 同等规模的输入,运行时间差距很大
   - 最差效率
   - 平均效率
   - 最有效率
4. 增长次数:当$输入规模 \to \infin$,算法运行时间表现出固定的增长次数

| 类型      | 名称     | 注释                                 | 1s内可以处理的数据规模 |
| --------- | -------- | ------------------------------------ | ---------------------- |
| $1$       | 常量     |                                      |                        |
| $log(n)$  | 对数     | 每一次循环消去问题规模的一个常熟因子 |                        |
| $n$       | 线性     | 单次循环扫描:顺序查找                | $5 * 10^8$             |
| $nlog(n)$ | 线性对数 | 分支:合并排序,快速排序               | $2*10^7$               |
| $n^2$     | 平方     |                                      |                        |
| $2^n$     | 指数     |                                      |                        |
| $n!$      | 阶乘     | 完全排列                             |                        |

#### 大O

**大O用来表示上界的**，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要**考虑数据规模**

$O(\log(n))$ 忽略底数：`以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数`。

![image-20210913213338694](/Image/B1.算法设计-photo/image-20210913213338694.png)

### 时间复杂度分析：

1. 确定基本操作

2. 构造基于基本操作的函数解析式

3. 求解函数解析式

4. 如果构建的是递推关系式，那么常用的求解方法有：

   - 前向替换法：找到闭合公式，通过带入初始方程或数学归纳证明

   - 反向替换法：$x(n)=x(n-1)+n = x(n - 2) + n-1 + n$, 重复这一过程

   - 变量替换：对于$f(n) = f(n/k) + b$ 
     $$
     \begin{aligned} 
      &f(n)= f(km-1)+b\\
      = & f(km-2)+2b = \cdots \\
     = & f(k0)+mb = f(1) + blog(n)\\
     \end{aligned}
     $$



递归算法的时间复杂度怎么计算？⼦问题总数 x 每个⼦问题的时间。

递归算法的时间复杂度本质上是要看: **递归的次数 * 每次递归中的操作次数**。

#### 从硬件配置看计算机的性能

计算机的运算速度主要看CPU的配置。CPU配置：2.7 GHz Dual-Core Intel Core i5 。

1Hz = 1/s，1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期），称之为为赫兹。

* 1GHz（兆赫）= 1000MHz（兆赫）= 10亿Hz
* 1MHz（兆赫）= 1百万赫兹

不要简单理解一个时钟周期就是一次CPU运算。例如1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。

* CPU执行每条指令所需的时间实际上并不相同，例如CPU执行加法和乘法操作的耗时实际上都是不一样的。
* 内存管理都有缓存技术，所以频繁访问相同地址的数据和访问不相邻元素所需的时间也是不同的。
* 计算机同时运行多个程序，每个程序里还有不同的进程线程在抢占资源。

### 空间复杂度分析

关注空间复杂度有两个常见的相关问题

1. 空间复杂度是考虑程序（可执行文件）的大小么？
   混淆程序运行时内存大小和程序本身的大小。强调**空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。**

2. 空间复杂度是准确算出程序运行时所占用的内存么？
   不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很有多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。所以空间复杂度是预先大体评估程序内存使用的大小。



| Data Structure                                               | Time Complexity |             |             |             |             |             |             |             | Space Complexity |
| ------------------------------------------------------------ | --------------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ---------------- |
|                                                              | Average         |             |             |             | Worst       |             |             |             | Worst            |
|                                                              | Access          | Search      | Insertion   | Deletion    | Access      | Search      | Insertion   | Deletion    |                  |
| [Array](http://en.wikipedia.org/wiki/Array_data_structure)   | `Θ(1)`          | `Θ(n)`      | `Θ(n)`      | `Θ(n)`      | `O(1)`      | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`           |
| [Stack](http://en.wikipedia.org/wiki/Stack_(abstract_data_type)) | `Θ(n)`          | `Θ(n)`      | `Θ(1)`      | `Θ(1)`      | `O(n)`      | `O(n)`      | `O(1)`      | `O(1)`      | `O(n)`           |
| [Queue](http://en.wikipedia.org/wiki/Queue_(abstract_data_type)) | `Θ(n)`          | `Θ(n)`      | `Θ(1)`      | `Θ(1)`      | `O(n)`      | `O(n)`      | `O(1)`      | `O(1)`      | `O(n)`           |
| [Singly-Linked List](http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_lists) | `Θ(n)`          | `Θ(n)`      | `Θ(1)`      | `Θ(1)`      | `O(n)`      | `O(n)`      | `O(1)`      | `O(1)`      | `O(n)`           |
| [Doubly-Linked List](http://en.wikipedia.org/wiki/Doubly_linked_list) | `Θ(n)`          | `Θ(n)`      | `Θ(1)`      | `Θ(1)`      | `O(n)`      | `O(n)`      | `O(1)`      | `O(1)`      | `O(n)`           |
| [Skip List](http://en.wikipedia.org/wiki/Skip_list)          | `Θ(log(n))`     | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`      | `O(n log(n))`    |
| [Hash Table](http://en.wikipedia.org/wiki/Hash_table)        | `N/A`           | `Θ(1)`      | `Θ(1)`      | `Θ(1)`      | `N/A`       | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`           |
| [Binary Search Tree](http://en.wikipedia.org/wiki/Binary_search_tree) | `Θ(log(n))`     | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`           |
| [Cartesian Tree](https://en.wikipedia.org/wiki/Cartesian_tree) | `N/A`           | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `N/A`       | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`           |
| [B-Tree](http://en.wikipedia.org/wiki/B_tree)                | `Θ(log(n))`     | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `O(log(n))` | `O(log(n))` | `O(log(n))` | `O(log(n))` | `O(n)`           |
| [Red-Black Tree](http://en.wikipedia.org/wiki/Red-black_tree) | `Θ(log(n))`     | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `O(log(n))` | `O(log(n))` | `O(log(n))` | `O(log(n))` | `O(n)`           |
| [Splay Tree](https://en.wikipedia.org/wiki/Splay_tree)       | `N/A`           | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `N/A`       | `O(log(n))` | `O(log(n))` | `O(log(n))` | `O(n)`           |
| [AVL Tree](http://en.wikipedia.org/wiki/AVL_tree)            | `Θ(log(n))`     | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `O(log(n))` | `O(log(n))` | `O(log(n))` | `O(log(n))` | `O(n)`           |
| [KD Tree](http://en.wikipedia.org/wiki/K-d_tree)             | `Θ(log(n))`     | `Θ(log(n))` | `Θ(log(n))` | `Θ(log(n))` | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`      | `O(n)`           |

#### Array Sorting Algorithms

| Algorithm                                                    | Time Complexity |                  |                  | Space Complexity |
| ------------------------------------------------------------ | --------------- | ---------------- | ---------------- | ---------------- |
|                                                              | Best            | Average          | Worst            | Worst            |
| [Quicksort](http://en.wikipedia.org/wiki/Quicksort)          | `Ω(n log(n))`   | `Θ(n log(n))`    | `O(n^2)`         | `O(log(n))`      |
| [Mergesort](http://en.wikipedia.org/wiki/Merge_sort)         | `Ω(n log(n))`   | `Θ(n log(n))`    | `O(n log(n))`    | `O(n)`           |
| [Timsort](http://en.wikipedia.org/wiki/Timsort)              | `Ω(n)`          | `Θ(n log(n))`    | `O(n log(n))`    | `O(n)`           |
| [Heapsort](http://en.wikipedia.org/wiki/Heapsort)            | `Ω(n log(n))`   | `Θ(n log(n))`    | `O(n log(n))`    | `O(1)`           |
| [Bubble Sort](http://en.wikipedia.org/wiki/Bubble_sort)      | `Ω(n)`          | `Θ(n^2)`         | `O(n^2)`         | `O(1)`           |
| [Insertion Sort](http://en.wikipedia.org/wiki/Insertion_sort) | `Ω(n)`          | `Θ(n^2)`         | `O(n^2)`         | `O(1)`           |
| [Selection Sort](http://en.wikipedia.org/wiki/Selection_sort) | `Ω(n^2)`        | `Θ(n^2)`         | `O(n^2)`         | `O(1)`           |
| [Tree Sort](https://en.wikipedia.org/wiki/Tree_sort)         | `Ω(n log(n))`   | `Θ(n log(n))`    | `O(n^2)`         | `O(n)`           |
| [Shell Sort](http://en.wikipedia.org/wiki/Shellsort)         | `Ω(n log(n))`   | `Θ(n(log(n))^2)` | `O(n(log(n))^2)` | `O(1)`           |
| [Bucket Sort](http://en.wikipedia.org/wiki/Bucket_sort)      | `Ω(n+k)`        | `Θ(n+k)`         | `O(n^2)`         | `O(n)`           |
| [Radix Sort](http://en.wikipedia.org/wiki/Radix_sort)        | `Ω(nk)`         | `Θ(nk)`          | `O(nk)`          | `O(n+k)`         |
| [Counting Sort](https://en.wikipedia.org/wiki/Counting_sort) | `Ω(n+k)`        | `Θ(n+k)`         | `O(n+k)`         | `O(k)`           |
| [Cubesort](https://en.wikipedia.org/wiki/Cubesort)           | `Ω(n)`          | `Θ(n log(n))`    | `O(n log(n))`    | `O(n)`           |



#### 伪随机数

1. 线性同余法



# 算法方法论

## 贪心法 (greedy approach)

> 贪心算法或贪心思想采用贪心的策略，保证**每次操作都是局部最优的**，从而使最后得到的结果是**全局最优**的。

步步为营一一通过局部最优，推出整体最优。每一步怎么走，取决于如何能够产生最大的短期收益并且不违反题设的约束。

难点在于证明真的能够产出最优解。

贪⼼算法⼀般分为如下四步：

- 将问题分解为若⼲个⼦问题
- 找出适合的贪⼼策略
- 求解每⼀个⼦问题的最优解
- 将局部最优解堆叠成全局最优解



### 基础题

#### 376. 摆动序列

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第⼀个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
> 例如， [1,7,4,9,2,5] 是⼀个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反,[1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第⼀个序列是因为它的前两个差值都是正数，第⼆个序列是因为它的最后⼀个差值为零。
> 给定⼀个整数序列，返回作为摆动序列的最⻓⼦序列的⻓度。 通过从原始序列中删除⼀些（也可以不删除）元素来获得⼦序列，剩下的元素保持其原始顺序。

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第⼀个差（如果存在
的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
例如， [1,7,4,9,2,5] 是⼀个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反,
[1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第⼀个序列是因为它的前两个差值都是正数，第⼆个序列是因
为它的最后⼀个差值为零。
给定⼀个整数序列，返回作为摆动序列的最⻓⼦序列的⻓度。 通过从原始序列中删除⼀些（也可以不删
除）元素来获得⼦序列，剩下的元素保持其原始顺序。

```cpp
class Solution {
public:
int wiggleMaxLength(vector<int>& nums) {
if (nums.size() <= 1) return nums.size();
int curDiff = 0; // 当前⼀对差值
int preDiff = 0; // 前⼀对差值
int result = 1;
// 记录峰值个数，序列默认序列最右边有⼀个峰值
for (int i = 0; i < nums.size() - 1; i++) {
curDiff = nums[i + 1] - nums[i];
// 出现峰值
if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0))
{
result++;
preDiff = curDiff;
}
}
return result;
}
};
```

#### 1005.K次取反后最⼤化的数组和

> 给定⼀个整数数组 A，我们只能⽤以下⽅法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同⼀个索引 i。）以这种⽅式修改数组后，返回数组可能的最⼤和。
> 示例 1：
> 输⼊：A = [4,2,3], K = 1
> 输出：5
> 解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。

本题的解题步骤为：

1. 第⼀步：将数组按照绝对值⼤⼩从⼤到⼩排序，注意要按照绝对值的⼤⼩
2. 第⼆步：从前向后遍历，遇到负数将其变为正数，同时K--
3. 第三步：如果K还⼤于0，那么反复转变数值最⼩的元素，将K⽤完
4. 第四步：求和

```cpp
class Solution {
static bool cmp(int a, int b) {
return abs(a) > abs(b);
}
public:
int largestSumAfterKNegations(vector<int>& A, int K) {
sort(A.begin(), A.end(), cmp);
// 第⼀步
for (int i = 0; i < A.size(); i++) { // 第⼆步
if (A[i] < 0 && K > 0) {
A[i] *= -1;
K--;
}
}
if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步
int result = 0;
for (int a : A) result += a;
return result;
}
};
```



### 分配问题

#### 135. 分发糖果

> ⽼师想给孩⼦们分发糖果，有 N 个孩⼦站成了⼀条直线，⽼师会根据每个孩⼦的表现，预先给他们评分。你需要按照以下要求，帮助⽼师给这些孩⼦分发糖果：
>
> - 每个孩⼦⾄少分配到 1 个糖果。
> - 相邻的孩⼦中，评分⾼的孩⼦必须获得更多的糖果。

存在比较关系的贪心策略不一定需要排序或是选择

**这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。**

只需要简单的两次遍历即可：把所有孩子的糖果数初始化为 1；

1. 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；
2. 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。
3. 通过这两次遍历，分配的糖果就可以满足题目要求了。



```cpp
class Solution {
    public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前for (int i = ratings.size() - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1] ) {
            candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
        }
    }
    // 统计结果
    int result = 0;
    for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
    return result;
}
```



#### 406.根据身⾼重建队列

> 假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。
>
> 请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
>
>  **示例 1：**
>
> ```cpp
> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> 解释：
> 插⼊的过程：
> 插⼊[7,0]：[[7,0]]
> 插⼊[7,1]：[[7,0],[7,1]]
> 插⼊[6,1]：[[7,0],[6,1],[7,1]]
> 插⼊[5,0]：[[5,0],[7,0],[6,1],[7,1]]
> 插⼊[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
> 插⼊[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> ```

如何确定⼀个维度，然后在按照另⼀个维度重新排列。

按照身⾼排序之后，优先按身⾼⾼的people的k来插⼊，后序插⼊节点也不会影响前⾯已经插⼊的节点，最终按照k的规则完成了队列。



```cpp
class Solution {
    public:
    // 身⾼从⼤到⼩排（身⾼相同k⼩的站前⾯）
    static bool cmp(const vector<int> a, const vector<int> b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插⼊效率⽐vector⾼的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插⼊到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            while (position--) { // 寻找在插⼊位置
                                it++;
                               }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
时间复杂度O(nlogn + n^2)
空间复杂度O(n)
```



#### 738.单调递增的数字

> 给定一个非负整数 `N`，找出小于或等于 `N` 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
>
> （当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的。）
>
> **示例 1:**
>
> ```cpp
> 输入: N = 10
> 输出: 9
> ```
>
> 

遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，可以保证这两位
变成最⼤单调递增整数。

确定从后向前遍历顺序，和维护标记从哪⼀位开始统⼀改成9。

```cpp
class Solution {
 public:
  int monotoneIncreasingDigits(int n) {
    string strNum = to_string(n);
    int pos = strNum.size();
    // pos⽤来标记赋值9从哪⾥开始
	// 设置为这个默认值，为了防⽌第⼆个for循环在flag没有被赋值的情况下执⾏
    for (int i = strNum.size() - 1; i > 0; i--) {
      if (strNum[i - 1] > strNum[i]) {
        pos = i;
        strNum[i - 1]--;
      }
    }
    for (int i = pos; i < strNum.size(); i++) {
      strNum[i] = '9';
    }
    return stoi(strNum);
  }
};
```





### 区间问题



#### 435. ⽆重叠区间

> 给定⼀个区间的集合，找到需要移除区间的最⼩数量，使剩余区间互不重叠。
> 注意:
> 可以认为区间的终点总是⼤于它的起点。
> 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

按照右边界排序，从左向右记录⾮交叉区间的个数。最后⽤区间总数减去⾮交叉区间的个数就是需要移除的区间个数了。

难点：

- 难点⼀：⼀看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。
- 难点⼆：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。
- 难点三：直接求重复的区间是复杂的，转⽽求最⼤⾮重复区间个数。
- 难点四：求最⼤⾮重复区间个数时，需要⼀个分割点来做标记。

排序比较策略

1. 在可选的工作中，每次都选取结束时间最早的工作
2. 在可选的工作中，每次都选取用时最短的工作
3. 在可选的工作中，每次都选取与最少可选工作有重叠的工作

算法1是正确的，而其余两种都可以找到对应的反例。或者说，在有些情况下，它们所选取的工作并非最优



```cpp
class Solution {
public:
// 按照区间右边界排序
static bool cmp (const vector<int>& a, const vector<int>& b) {
return a[1] < b[1];
}
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
if (intervals.size() == 0) return 0;
sort(intervals.begin(), intervals.end(), cmp);
int count = 1; // 记录⾮交叉区间的个数
int end = intervals[0][1]; // 记录区间分割点
for (int i = 1; i < intervals.size(); i++) {
if (end <= intervals[i][0]) {
end = intervals[i][1];
count++;
}
}
return intervals.size() - count;
}
};
时间
```



#### 452. ⽤最少数量的箭引爆⽓球

> 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
>
> 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
>
> 给你一个数组 `points` ，其中 `points [i] = [xstart,xend]` ，返回引爆所有气球所必须射出的最小弓箭数。
>
> ```Cpp
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]
> 输出：2
> 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球
> ```

局部最优：当⽓球出现重叠，⼀起射，所⽤⼸箭最少。全局最优：把所有⽓球射爆所⽤⼸箭
最少。

1. 为了让⽓球尽可能的重叠，需要对数组进⾏排序。
2. 如果⽓球重叠了，重叠⽓球中右边边界的最⼩值 之前的区间⼀定需要⼀个⼸箭。

```cpp
class Solution {
    private:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    }
    public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if (points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);
        int result = 1; // points 不为空⾄少需要⼀⽀箭
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > points[i - 1][1]) {
                // ⽓球i和⽓球i-1不挨着，注意这⾥不是>=
                result++; // 需要⼀⽀箭
            }
            else {
                // ⽓球i和⽓球i-1挨着
                points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠⽓球最⼩右
                边界
            }
        }
        return result;
}};
```



#### 763.划分字⺟区间

> 字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
>
> **示例：**
>
> ```cpp
> 输入：S = "ababcbacadefegdehijhklij"
> 输出：[9,7,8]
> 解释：
> 划分结果为 "ababcbaca", "defegde", "hijhklij"。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
> ```
>
> **提示：**
>
> - `S`的长度在`[1, 500]`之间。
> - `S`只包含小写字母 `'a'` 到 `'z'` 。

两步：

1. 统计每⼀个字符最后出现的位置
2. 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点

```cpp
class Solution {
    public:
    vector<int> partitionLabels(string S) {
        int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置
        for (int i = 0; i < S.size(); i++) { // 统计每⼀个字符最后出现的位置
             hash[S[i] - 'a'] = i;
        }
        vector<int> result;
        int left = 0;
        int right = 0;
        for (int i = 0; i < S.size(); i++) {
            right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界
            if (i == right) {
                result.push_back(right - left + 1);
                left = i + 1;
            }
        }
        return result;
    }
};
```

#### 56. 合并区间

> 给出⼀个区间的集合，请合并所有重叠的区间。

照左边界排序，排序之后局部最优：每次合并都取最⼤的右边界

```cpp
class Solution {
    public:
    // 按照区间左边界从⼩到⼤排序
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;
        if (intervals.size() == 0) return result;
        sort(intervals.begin(), intervals.end(), cmp);
        bool flag = false; // 标记最后⼀个区间有没有合并
        int length = intervals.size();
        for (int i = 1; i < length; i++) {
            int start = intervals[i - 1][0]; // 初始为i-1区间的左边界
            int end = intervals[i - 1][1]; // 初始i-1区间的右边界while (i < length && intervals[i][0] <= end) { // 合并区间
            end = max(end, intervals[i][1]); // 不断更新右区间
            if (i == length - 1) flag = true; // 最后⼀个区间也合并了
            i++; // 继续合并下⼀个区间
        }
        // start和end是表示intervals[i - 1]的左边界右边界，所以最优intervals[i]区间是否合
        并了要标记⼀下
        result.push_back({start, end});
    }
    // 如果最后⼀个区间没有合并，将其加⼊result
    if (flag == false) {
        result.push_back({intervals[length - 1][0], intervals[length - 1][1]});
    }
    return result;
}
```





#### 55. 跳跃游戏

> 给定⼀个⾮负整数数组，你最初位于数组的第⼀个位置。
> 数组中的每个元素代表你在该位置可以跳跃的最⼤⻓度。
> 判断你是否能够到达最后⼀个位置。

其实跳⼏步⽆所谓，关键在于可跳的覆盖范围！

**那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！**

**贪⼼算法局部最优解：每次取最⼤跳跃步数（取最⼤覆盖范围），整体最优解：最后得到整体最⼤覆盖范围，看是否能到终点。**

```cpp
class Solution {
public:
bool canJump(vector<int>& nums) {
int cover = 0;
if (nums.size() == 1) return true; // 只有⼀个元素，就是能达到
for (int i = 0; i <= cover; i++) { // 注意这⾥是⼩于等于cover
cover = max(i + nums[i], cover);
if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
}
return false;
}
};
```



#### 45.跳跃游戏II

> 给定⼀个⾮负整数数组，你最初位于数组的第⼀个位置。
> 数组中的每个元素代表你在该位置可以跳跃的最⼤⻓度。
> 你的⽬标是使⽤最少的跳跃次数到达数组的最后⼀个位置。

贪⼼的思路，局部最优：当前可移动距离尽可能多⾛，如果还没到终点，步数再加⼀。整体最优：⼀步尽可能多⾛，从⽽达到最⼩步数。

**以最⼩的步数增加最⼤的覆盖范围，直到覆盖范围覆盖了终点，这个范围内最⼩步数⼀定可以跳到，不⽤管具体是怎么跳的，不纠结于⼀步究竟跳⼀个单位还是两个单位。**
**这⾥需要统计两个覆盖范围，当前这⼀步的最⼤覆盖和下⼀步最⼤覆盖。**

⽅法⼀：

这⾥还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时

- 如果当前覆盖最远距离下标不是集合终点，步数就加⼀，还需要继续⾛。
- 如果当前覆盖最远距离下标就是集合终点，步数不⽤加⼀，因为不能再往后⾛了。

```cpp
// 版本⼀
class Solution {
public:
int jump(vector<int>& nums) {
if (nums.size() == 1) return 0;
int curDistance = 0; // 当前覆盖最远距离下标
int ans = 0; // 记录⾛的最⼤步数
int nextDistance = 0; // 下⼀步覆盖最远距离下标
for (int i = 0; i < nums.size(); i++) {
nextDistance = max(nums[i] + i, nextDistance); // 更新下⼀步覆盖最远距离下标
if (i == curDistance) { // 遇到当前覆盖最远距离下标
if (curDistance != nums.size() - 1) {
// 如果当前覆盖最远距离下标不是
终点
ans++; // 需要⾛下⼀步
curDistance = nextDistance; // 更新当前覆盖最远距离下标（相
当于加油了）
if (nextDistance >= nums.size() - 1) break; // 下⼀步的覆盖范围已经可以
达到终点，结束循环
} else break;
// 当前覆盖最远距离下标是集合终
点，不⽤做ans++操作了，直接结束
}
}
return ans;
}
};
```



⽅法⼆：



#### POJ3069.Saruman's Army

> 直线上有N个点。点i的位置是X。从这N个点中选择若干个，给它们加上标记。对每一个
> 点，其距离为R以内的区域里必须有带有标记的点（自己本身带有标记的点，可以认为与其距离为0的地方有一个带有标记的点）。在满足这个条件的情况下，希望能为尽可能少的点最加标记。请问至少要有多少点被加上标记
>
> ![image-20210925200723775](/Image/B1.算法设计-photo/image-20210925200723775.png)

- 从最左边开始考虑。对于这个点，到距其R以内的区域内必须要有带有标记的点。
- 显然从最左边的点开始，距离为R以内的最远的点，首先被标记。因为更左的区域没有覆盖的意义，所以应该尽可能覆盖更靠右的点。
  ![image-20210925200739033](/Image/B1.算法设计-photo/image-20210925200739033.png)
- 加上了第一个标记后，剩下的部分也用同样的办法处理。对于添加了符号的点右侧相距超过R的下一个点，采用同样的方法
  ![image-20210925200751407](/Image/B1.算法设计-photo/image-20210925200751407.png)
- 重复这一过程

 


```cpp
const int MAX_N = 1000;
int arr[MAX_N + 5];

int solve(int n, int r) {
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    sort(arr, arr + n);
    int index = 0, count = 0;
    while (index < n) {
        int s = arr[index++];
        while (index < n && s + r >= arr[index]) index++;
        int p = arr[index - 1];
        while (index < n && p + r >= arr[index]) index++;
        count++;
    }
    return count;
}

int main() {
    int n, r;
    while (cin >> r >> n) {
        if (n == -1 || r == -1) break;
        cout << solve(n, r) << endl;
    }
}
```

#### POJ 3253.Fence Repair

> 农夫约翰为了修理栅栏，要将一块很长的木板切制成N块。准备切成的木板的长度为$L_1$、$L_2$、$\cdots$、$L_N$，未切割前木板的长度恰好为切割后木板长度的总和。每次切断木板时，需要的开销为这块木板的长度。
>
> 例如长度为21的木板要切成长度为5、8、8的三块木板。长21的木板切成长为13和8的板时，开销为21。再将长度为13的板切成长度为5和8的板时，开销是13。于是合计开销是34。
>
> 请求出按照目标要求将木板切割完最小的开销是多少。

![image-20210925202244562](/Image/B1.算法设计-photo/image-20210925202244562.png)

每一个叶子节点就对应了切割出的一块块木板。叶子节点的深度就对应了为了得到对应木板
听需的切割次数，开销的合计就是各**叶子节点的木板的长度×节点的深度**

此时的最佳切割方法首先应该具有如下性质：**最短的板与次短的板的节点应当是兄弟节点兄弟节点**，

**最短的板应当是深度最大的叶子节点之一。**而且由于与这个叶子节点同一深度的兄弟节点一定存在，并且由于同样是最深的叶子节点，所以应该对应于次短的板。

哈夫曼树





### 字典序最小问题

> Best CowLine（POJ3617）
> 给定长度为N的字特串S，要构造一个长度为N的字符串T。起初，T是一个空串，随后反复进行下列任意操作
> - S的头部删除1个字符，加到T的尾部
> - S的尾部删除1个字符，加到T的尾部
>
> 目标是要构造字典序尽可能小的字符串T

从字典序的性质上看，无论T的末尾有多大，只要前面部分的较小就可以。

- 不断取S的开头和末尾中较小的一个字符放到T的末尾
  这个算法已经接近正确了，只是针对S的开头和末尾字符相同的情形还没有定义。在这种情形下,因为我们希望能够尽早使用更小的字符，所以就要比较下一个字符的大小。下一个字符也有可能相同，因此就有如下算法:
- 按照字典序比较S和将S反转后的字符串S’
- 如果S较小，就从S的开头取出一个文字，追加到T的末尾
- 如果S’较小，就从S的末尾取出一个文学，追加到T的末尾
- 如果相同则取哪个都可以

根据前面提到的性质，字典序比较类的问题经常能用得上贪心

```cpp
const int MAX_N = 2000;
char s[MAX_N + 5];

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> s[i];
    }
    int a = 0, b = n - 1, count = 0;
    while (a <= b) {
        bool left = false;
        for (int i = 0; i <= b - a; i++) {
            if (s[a + i] < s[b - i]) {
                left = true;
                count++;
                break;
            } else if (s[a + i] > s[b - i]) {
                count++;
                left = false;
                break;
            }
        }
        if (left) putchar(s[a++]);
        else putchar(s[b--]);
        if (count % 80 == 0) cout << endl;
    }
    cout << endl;
    return 0;
}

```

### other

#### 134. 加油站

> 在⼀条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
> 你有⼀辆油箱容量⽆限的的汽⻋，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的⼀个加油站出发，开始时油箱为空。
> 如果你可以绕环路⾏驶⼀周，则返回出发时加油站的编号，否则返回 -1。



## 双指针

> 双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。
> 若两个指针指向同一数组，遍历方向相同且不会相交，则也称为**滑动窗口**（两个指针包围的区域即为当前的窗口），经常用于区间搜索。
> 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。

### Two Sum

> 在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。

数组已经排好序，我们可以采用方向相反的双指针来寻找这两个数字。

对于排好序且有解的数组，双指针一定能遍历到最优解。证明方法如下：假设最优解的两个数的位置分别是 l 和 r。我们假设在左指针在 l 左边的时候，右指针已经移动到了 r；此时两个指针指向值的和小于给定值，因此左指针会一直右移直到到达 l。同理，如果我们假设在右指针在 r 右边的时候，左指针已经移动到了 l；此时两个指针指向值的和大于给定值，因此右指针会一直左移直到到达 r。所以双指针在任何时候都不可能处于 (l, r) 之间，又因为不满足条件时指针必须移动一个，所以最终一定会收敛在 l 和 r。

### 归并两个有序数组

> 给定两个有序数组，把两个数组合并为一个。
>
> 输入是两个数组和它们分别的长度 m 和 n。其中第一个数组的长度被延长至 m + n，多出的n 位被 0 填补。题目要求把第二个数组归并到第一个数组上，不需要开辟额外空间。
> Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> Output: nums1 = [1,2,2,3,5,6]

因为这两个数组已经排好序，我们可以把两个指针分别放在两个数组的末尾，次将较大的那个数字复制。

### 快慢指针

1. 计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。
2. 判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。（Floyd 判圈法）
3. 判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。
4. 求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了
5. 求链表倒数第k个元素：先让其中一个指针向前走k步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第k个元素。（严格来说应该叫先后指针而非快慢指针）
6. 找唯一重复元素

给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast可以走到尽头，那么说明没有环路；如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点

> 给定一个链表，如果有环路，找出环路的开始点。

```cpp
ListNode *detectCycle(ListNode *head) {
	ListNode *slow = head, *fast = head;
// 判断是否存在环路
	do {
		if (!fast || !fast->next) return nullptr;
		fast = fast->next->next;
		slow = slow->next;
	} while (fast != slow);
// 如果存在，查找环路节点
	fast = head;
	while (fast != slow){
	slow = slow->next;
	fast = fast->next;
	}
	return fast;
}
```

### 滑动窗口

用滑动窗口求解，即两个指针 l 和 r 都是从最左端向最右端移动，且 l 的位置一定在r 的左边或重合。

> > 最小覆盖子串
>
> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。
>
> **注意：**
>
> - 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
> - 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
注意本题虽然在 for 循环里出现了一个 while 循环，但是因为 while 循环负责移动 l 指针，且 l 只会从左到右移动一次，因此总时间复杂度仍然是 O(n)。本题使用了长度为 128的数组来映射字符，也可以用哈希表替代；其中 chars 表示目前每个字符缺少的数量，flag 表示每个字符是否在 T 中存在。

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> chars(128, 0);
        vector<bool> flags(128, false);
        for (int i = 0; i < t.size(); i++) {
            flags[t[i]]  = true;
            chars[t[i]]++;
        }
        int cnt = 0, l = 0, min_l = 0, min_size = s.size() + 1;
        for (int r = 0; r < s.size(); ++r) {
            if (flags[s[r]] == false) continue;
            if (--chars[s[r]] >= 0) {
                ++cnt;
            }
            while (cnt == t.size()) {
                if (r - l + 1 < min_size) {
                    min_l = l;
                    min_size = r - l + 1;
                }
                if (flags[s[l]] && ++chars[s[l]] > 0) {
                    --cnt;
                }
                ++l;
            }

        }
        return min_size > s.size()? "": s.substr(min_l, min_size);
    }
};
```

## 二分查找

二分搜索方面 ， STL 在库中提供了 binary search 、 lower bound 、 upper bound 


lower bound 是一种应用于有序数据范围内的算法 ， 返回一个迭代器，指向第一个不小于指定值 value 的元素 。  upper bound 返回的迭代器指向第一个大于指定值 value 的元素

```cpp
int binary_search(int (*arr)(int), int x, int n) {
    int l = 0, r = n - 1, mid;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (arr(mid) == x) return mid;
        else if (arr(mid) > x) r = mid - 1;
        else l = mid  + 1;
    }
    return -1;
}

int binary_2(int (*arr)(int), int l, int r, int x) {

    int mid = (l + r) >> 1;
    if (arr(mid) == x) return mid;
    if (l > r) return -1;
    if (arr(mid) > x) r = mid - 1;
    else l = mid + 1;
    return binary_2( arr, l, r, x);
}

//  {1, 1, 1, 1, 1, 1, 0, 0, 0, 0};
int binary_search(int *arr, int n) {
    int head = -1, tail = n - 1, mid;
    while (head < tail) {
        cout << "head: " << head << " tail" << tail << endl;
        mid = (head + tail + 1) >> 1;
        if (arr[mid] == 1) head = mid;
        else tail = mid - 1;
    }
    cout << head << endl;;
    return head;
}

//  {0, 0, 0, 0, 1, 1, 1, 1, 1, 1};

int binary_search(int *arr, int n) {
    int head = 0, tail = n, mid;
    while (head < tail) {
        cout << "head: " << head << " tail: " << tail << endl;
        mid = (head + tail) >> 1;
        if (arr[mid] == 1) tail = mid;
        //if (arr[mid - 1] == 1) tail = mid - 1;
        else head = mid + 1;
    }
    return head != n ? tail : -1;
}



```



### 从有序数组中查找某个值

### 假定一个解并判断是否可行

#### （POJNo.1064）Cable master

> 有N条绳子，它们的长度分别为L。如果从它们中切制出K条长度相同的绳子的话，这K条绳子每条最长能有多长？答案保留到小数点后2位

令：条件 $C(x)$ = 可以得到 $K$ 条长度为 $x$ 的绳子，则问题变成了求满足 $C(x)$ 条件的最大的 $x$。在区间初始化时，只需使用充分大的数$INF>MAX_L$,作为上界即可：
$C（x）=（floor(L_i/x）的总和是否大于或等于K）$

### 最大化最小值或最小化最大值的问题，

Aggressive cows（POJ No.2456）

> 农夫约翰搭了一间有N间牛舍的小屋。牛舍排在一条线上，第i号牛舍在x的位置。但是他的M头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其他牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离

定义 $C(d) = 可以安排牛的位置使得最近的两头牛的距离不小于d$
那么问题就变成了求满足 $C(d)$ 的最大的 $d$。

另外，最近的间距不小于也可以说成是所有牛的间距都不小于d，因此就有
$C(d) = 可以要排牛的位置使得任意的牛的同距都不小于d$
这个问题的判断使用贪心法便可求解

- 对牛舍的位置 $x$ 进行排序
- 把第一头牛放入 $x_0$ 的牛舍
- 如果第 $i$ 头牛放人了 $x_j$ 的话，第 $i + 1$ 头牛就要放满足 $x_j+d≤x_k$ 的最小的 $x_k$中



```cpp
bool C(int d) {
	int last = 0;
	for (int i = 1; i < M; i++) {
		int crt = last + 1;
		while (crt < N && x[crt] - x[last] < d) {
			crt++;
        }
        if (crt == N) return false;
		last = crt;
    }
    return trueÿ
}
```





### 最大化平均值

> 有n个物品的重量和价值分别是w和v。从中选出k个物品使得单位重量的价值最大
>
> 输入
>
> n=3,k=2
>
> $\{w,v\}= \{\{2,2\}, \{5,3\}, \{2,1\}\}$
>
> 输出
> 0.75 ( 如果选0号和2号物品,平均 价值是 $(2+1)/(2+2)=0.75$

最先想到的方法可能是把物品按照单位价值进行排序，从大到小贪心地进行选取。但是这个
方法对于样例输人得到的结果是5/7-0.714。所以这个方法是不可行的。

定义条件 $C(x)=可以选择使得单位重量的价值不小于x$
因此，原问题就变成了求满足 $C(x)$ 的最大的 $x$。

假设我们选了某个物品的集合S，那么它们的单位重量的价值是 $\sum_{i \in S}v_i / \sum_{i \in S}w_i $

因此就变成了判断是否存在S满足下面的条件$\sum_{i \in S}v_i / \sum_{i \in S}w_i \ge x $
把这个不等式进行变形就得到 $\sum_{i \in S}(v_i - x \times w_i) \ge 0 $
对 $(v_i - x \times w_i)$ 的值进行排序贪心地进行选取。因此就变成了
$C(x)=(v_i - x \times w_i)从大到小排列中的前k个的和不小于0$

```cpp
bool C(double x) {
	for (int i = 0; i < n; i++) {
		y[i] = v[i] - x * w[i ] ;
    }
    sort(y, y + n);
//计算y数组 中从大到小前k 个数的和
	double sum = 0;
 	for (int i = 0; i < k; i++) {
		sum += y[n - i - 1];
     }
    return sum >= 0;
}               
```





> 二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找

二分查找时区间的左右端的开闭问题：
1. 第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；
2. 第二是在思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环

### 求开方

> 给定一个非负整数，求它的开方，向下取整。
>
> Input: 8
> Output: 2
>
> > 8 的开方结果是 2.82842...，向下取整即是 2。

给定一个非负整数 $a$，求 $f (x) = x^2 − a = 0$ 的解。因为我们只考虑 $x ≥ 0$，所以 $f (x)$ 在定义域上是单调递增的。考虑到 $f (0) = −a ≤ 0$， $f (a) = a^2 − a ≥ 0$，我们可以对 $[0, a]$ 区间使用二分法找到 $f (x) = 0$ 的解。

```cpp
/*
 * @lc app=leetcode.cn id=69 lang=cpp
 *
 * [69] x 的平方根
 */
class Solution {
public:
    int mySqrt(int x) {
        if (x <= 0) return 0;
        long long l = 0, r = x;
        while (l < r) {
            int mid = l + ((r - l + 1) >> 1);
            //int mid = (l + r + 1) / 2;
            if (mid <= x / mid) l = mid;
            else r = mid - 1;
        }
        return (int)l;
    }
};
```

**牛顿迭代法**

> 五次及以上多项式方程没有根式解（就是没有像二次方程那样的万能公式），这个是被伽罗瓦用群论做出的最著名的结论。
>
> 没有根式解不意味着方程解不出来，数学家也提供了很多方法，牛顿迭代法就是其中一种。

**切线是曲线的线性逼近**

A点的切线是 $f(x)$ 的线性逼近。离A点距离越近，这种逼近的效果也就越好，也就是说，切线与曲线之间的误差越小。所以我们可以说在A点附近，“切线$\approx f(x)$

![index-2](/Image/B1.算法设计-photo/index-2.png)

经过无数次迭代也只会更接近曲线的根，数学术语：迭代收敛

![index-2](/Image/B1.算法设计-photo/index-2-1632304568813.png)
$x_n$ 点的切线方程为 $f(x_n) + f'(x_n)(x - x_n)$
求$x_{n+1}$ 即求 $f(x_n) + f'(x_n)(x - x_n) = 0$ 的解，即 $x_{n+1} = x_{n} - \frac{f(x_n)}{f'(x_n)}$

应用牛顿-拉弗森方法，要注意以下问题：

- 函数在整个定义域内最好是二阶可导的 
- 起始点对求根计算影响重大，可以增加一些别的判断手段进行试错 

给定$f (x) = x^2 − a = 0$，迭代公式为 $x_{n+1} = (x_n - a /x_n)/2$

```cpp
int mySqrt(int a) {
	long x = a;
	while (x * x > a) {
	x = (x + a / x) / 2;
	}
	return x;
}
```

### 查找区间

> 给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。

```cpp
/*
 * @lc app=leetcode.cn id=34 lang=cpp
 *
 * [34] 在排序数组中查找元素的第一个和最后一个位置
 */
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int p1 = findTheFirst(nums, target + 1) - 1;
        int p2 = findTheFirst(nums, target);
        vector<int> ans;
        if (p1 >= p2) {
            ans = {p2, p1};
        } else {
            ans  = {-1, -1};
        }
        return ans;
    }
    int findTheFirst(vector<int> &nums, int target) {
        int l = 0, r = nums.size();
        while (l < r) {
            int mid = (l + r) >> 1;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
```

### 旋转数组查找数字

> 一个原本增序的数组被首尾相连后按某个位置断开（如 [1,2,2,3,4,5] → [2,3,4,5,1,2]，在第一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。

允许出现重复元素，则如果 $A[left] \le A[mid]$，则序列$[left, mid]$不一定为递增序列。

如$1$，$3$，$1$，$1$，$1$。

拆分条件：

1. 如果 $A[left] \lt A[mid]$，则序列$[left, mid]$一定为递增序列。

2. 如果$A[left] = A[mid]$，则`left++`，往下走一步

   

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1, mid;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if(nums[mid] == target)return true;
            if(nums[mid] == nums[left]) left++;
            else if(nums[mid] <= nums[right]){
                if(nums[mid] < target && target <= nums[right]){
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            else{
                if(nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        return false;
    }
};
```

## 排序

sort 属于不稳定的排序算法 。以归并排序为基础的 stable _ sort。

```cpp
//快速排序（Quicksort）左闭右闭的二分写法。
void quick_sort(vector<int> &nums, int l, int r) {
  if (l + 1 >= r) {
    return;
  }
  int first = l, last = r - 1, key = nums[first];
  while (first < last) {
    while (first < last && nums[last] >= key) {
      --last;
    }
    nums[first] = nums[last];
    while (first < last && nums[first] <= key) {
      ++first;
    }
    nums[last] = nums[first];
  }
  nums[first] = key;
  quick_sort(nums, l, first);
  quick_sort(nums, first + 1, r);
}
//归并排序（Merge Sort） 
void merge_sort(vector<int> &nums, int l, int r, vector<int> &temp) {
  if (l + 1 >= r) {
    return;
  }
  // divide
  int m = l + (r - l) / 2;
  merge_sort(nums, l, m, temp);
  merge_sort(nums, m, r, temp);
  // conquer
  int p = l, q = m, i = l;
  while (p < m || q < r) {
    if (q >= r || (p < m && nums[p] <= nums[q])) {
      temp[i++] = nums[p++];
    } else {
      temp[i++] = nums[q++];
    }
  }
  for (i = l; i < r; ++i) {
    nums[i] = temp[i];
  }
}
//插入排序（Insertion Sort） 
void insertion_sort(vector<int> &nums, int n) {
  for (int i = 0; i < n; ++i) {
    for (int j = i; j > 0 && nums[j] < nums[j - 1]; --j) {
      swap(nums[j], nums[j - 1]);
    }
  }
}
//冒泡排序（Bubble Sort） 
void bubble_sort(vector<int> &nums, int n) {
  bool swapped;
  for (int i = 1; i < n; ++i) {
    swapped = false;
    for (int j = 1; j < n - i + 1; ++j) {
      if (nums[j] < nums[j - 1]) {
        swap(nums[j], nums[j - 1]);
        swapped = true;
      }
    }
    if (!swapped) {
      break;
    }
  }
}
//选择排序（Selection Sort） 
void selection_sort(vector<int> &nums, int n) {
  int mid;
  for (int i = 0; i < n - 1; ++i) {
    mid = i;
  for (int j = i + 1; j < n; ++j) {
      if (nums[j] < nums[mid]) {
        mid = j;
      }
    }
    swap(nums[mid], nums[i]);
  }
}

//以上排序代码调用方法为
void sort() {
  vector<int> nums = {1, 3, 5, 7, 2, 6, 4, 8, 9, 2,
                      8, 7, 6, 0, 3, 5, 9, 4, 1, 0};
  vector<int> temp(nums.size());
  sort(nums.begin(), nums.end());
  quick_sort(nums, 0, nums.size());
  merge_sort(nums, 0, nums.size(), temp);
  insertion_sort(nums, nums.size());
  bubble_sort(nums, nums.size());
  selection_sort(nums, nums.size());
}
```

#### 快速选择

> 在一个未排序的数组中，找到第 k 大的数字。



```cpp
/*
 * @lc app=leetcode.cn id=215 lang=cpp
 *
 * [215] 数组中的第K个最大元素
 */

// @lc code=start
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        return getKth(nums, 0, nums.size() - 1, nums.size() - k);
    }
    int getKth(vector<int> &arr, int l, int r, int idx) {
        int x = partition(arr, l, r);
        if (x == idx) return arr[x];
        return x < idx ? getKth(arr, x + 1, r, idx) : getKth(arr, l, x - 1, idx);
    }

    int partition(vector<int> &arr, int l, int r) {
        int ind = rand() % (r - l + 1) + l;
        swap(arr[ind], arr[l]);
        int val = arr[l];
        int x = l, y = r;
        while (x < y) {
            while (x < y && arr[y] >= val) y--;
            if (x < y) arr[x++] = arr[y];
            while (x < y && arr[x] <= val) x++;
            if (x < y) arr[y--] = arr[x];
        }
        arr[x] = val;
        return x;
    }
};
// @lc code=end

```

k-th Element 问题

```cpp
int findKthLargest(vector<int>& nums, int k) {
  int l = 0, r = nums.size() - 1, target = nums.size() - k;
  while (l < r) {
    int mid = quickSelection(nums, l, r);
    if (mid == target) {
		return nums[mid];
    }
    if (mid < target) {
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }
  return nums[l];
}
// 辅函数 - 快速选择
int quickSelection(vector<int>& nums, int l, int r) {
  int i = l + 1, j = r;
  while (true) {
    while (i < r && nums[i] <= nums[l]) {
      ++i;
    }
    while (l < j && nums[j] >= nums[l]) {
      --j;
    }
    if (i >= j) {
      break;
    }
    swap(nums[i], nums[j]);
  }
  swap(nums[l], nums[j]);
  return j;
}
5
```

#### 桶排序

> 给定一个数组，求前 k 个最频繁的数字。

桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属性），然后对桶进行排序。针对样例来说，我们先通过桶排序得到三个桶 [1,2,3,4]，它们的值分别为 [4,2,1,1]，表示每个数字出现的次数。

紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说，因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]，表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。

```cpp
/*
 * @lc app=leetcode.cn id=347 lang=cpp
 *
 * [347] 前 K 个高频元素
 */

// @lc code=start
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> counts;
        int max_count = 0;
        for (const int &num : nums) {
            max_count = max(max_count, ++counts[num]);
        }
        vector<vector<int>> buckets(max_count + 1);
        for (const auto &p : counts) {
            buckets[p.second].push_back(p.first);
        }
        vector<int> ans;
        for (int i = max_count; i >= 0 && ans.size() < k; --i) {
            for (const int &num : buckets[i]) {
                ans.push_back(num);
                if (ans.size() == k) {
                    break;
                }
            }
        }
        return ans;
    }
};
// @lc code=end

```

## 搜索

> **深度优先搜索**和**广度优先搜索**是两种最常见的优先搜索方法，它们被广泛地运用在图和树等结构中进行搜索。
>
> 深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用**先入后出**的栈来实现，也可以通过与栈等价的**递归**来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。

### 深搜（depth-first seach，DFS）

深度优先搜索也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍历且父节点不同，则说明有环。

拓扑排序判断是否有环路，若最后存在入度不为零的点，则说明有环。

对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这种做法叫做**状态记录**或**记忆化**（memoization）。



#### [695.岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/description/)

> 给定一个二维的 0-1 矩阵,其中 0 表示海洋,1 表示陆地。单独的或相邻的陆地可以形成岛
> 屿,每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。



**边界判定**：

1. 一种是先判定是否越界,只有在合法的情况下才进行下一步搜索(即判断放在调用递归函数前);
2. 另一种是先进行下一步搜索,待下一步搜索开始时再判断是否合法(即判断放在辅函数第一行)。我

```cpp
// 先判定是否越界
int dfs(vector<vector<int>>& grid, int r, int c) {
  if (grid[r][c] == 0) return 0;
  grid[r][c] = 0;
  int x, y, area = 1;
  for (int i = 0; i < 4; ++i) {
    x = r + direction[i], y = c + direction[i + 1];
    if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size()) {
      area += dfs(grid, x, y);
    }
  }
  return area;
}

// 先进行下一步搜索
int dfs(vector<vector<int>>& grid, int r, int c) {
  if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() ||
      grid[r][c] == 0) {
    return 0;
  }
  grid[r][c] = 0;
  return 1 + dfs(grid, r + 1, c) + dfs(grid, r - 1, c) + dfs(grid, r, c + 1) +
         dfs(grid, r, c - 1);
}
```



#### [417.太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/description/)

> 给定一个 `m x n` 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。
>
> 规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。
>
> 请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 
>
> **示例：**
>
> ```
> 给定下面的 5x5 矩阵:
> 
>   太平洋 ~   ~   ~   ~   ~ 
>        ~  1   2   2   3  (5) *
>        ~  3   2   3  (4) (4) *
>        ~  2   4  (5)  3   1  *
>        ~ (6) (7)  1   4   5  *
>        ~ (5)  1   1   2   4  *
>           *   *   *   *   * 大西洋
> 
> 返回:
> 
> [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
> ```

反过来想,从两个大洋开始向上流,这样我们只需要对矩形四条边进行搜索

```cpp
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        if (heights.empty() || heights[0].empty()) {
            return {};
        }
        vector<vector<int>> ans;
        int n = heights.size(), m = (n ? heights[0].size() : 0);
        vector<vector<bool>> can_reach_p(n, vector<bool>(m, false));
        vector<vector<bool>> can_reach_a(n, vector<bool>(m, false));
        for (int i = 0; i < n; i++) {
            dfs(heights, can_reach_p, i, 0);
            dfs(heights, can_reach_a, i, m - 1);
        }
        for (int i = 0; i < m; i++) {
            dfs(heights, can_reach_p, 0, i);
            dfs(heights, can_reach_a, n - 1, i);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (can_reach_a[i][j] && can_reach_p[i][j]) {
                    ans.push_back(vector<int>{i, j});
                }
            }
        }
        return ans;
    }

    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
    void dfs(const vector<vector<int>>& heights, vector<vector<bool>> &can_reach,int r, int c) {
        if (can_reach[r][c]) return ;
        can_reach[r][c] = true;
        for (int i = 0; i < 4; i++) {
            int x = r + dir[i][0];
            int y = c + dir[i][1];
            if (x < 0 || x >= heights.size()) continue;
            if (y < 0 || y >= heights[0].size()) continue;
            if (heights[x][y] < heights[r][c]) continue;
            dfs(heights, can_reach, x, y);
        }
        return ;
    }
};
```





## 回溯法（backtracking）

回溯法是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。

**回溯法解决的问题都可以抽象为树形结构，为状态空间树(state-space tree)。**

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

**回溯的本质是穷举，暴力穷举所有可能，然后选出我们想要的答案。**

在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且**把在目前节点修改的状态还原**。

这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。

回溯法，一般可以解决如下几种问题：

* 组合问题：N个数里面按一定规则找出k个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个N个数的集合里有多少符合条件的子集
* 排列问题：N个数按一定规则全排列，有几种排列方式
* 棋盘问题：N皇后，解数独等等

**组合是不强调元素顺序的，排列是强调元素顺序**。

回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标记，比如矩阵里搜字符串。



小诀窍：**一是按引用传状态，二是所有的状态修改在递归完成后回改。**

![回溯算法理论基础](https://img-blog.csdnimg.cn/20210130173631174.png)

解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。

1. 路径：也就是已经做出的选择。
2. 选择列表：也就是你当前可以做的选择。
3. 结束条件：也就是到达决策树底层，⽆法再做选择的条件。

```cpp
result = []
def backtrack(路径, 选择列表):
	if 满⾜结束条件:
	result.add(路径)
	return
	
    for 选择 in 选择列表:
	做选择
	backtrack(路径, 选择列表)
	撤销选择
```

其核⼼就是 for 循环⾥⾯的递归，在递归调⽤之前「做选择」，在递归调⽤之后「撤销选择」





#### [46.全排列](https://leetcode-cn.com/problems/permutations/description/)

对于每一个当前位置 i,我们可以将其于之后的任意位置交换,然后继续处理位置 i+1,直到处理到最后一位。

为了防止我们每此遍历时都要新建一个子数组储存位置 i 之前已经交换好的数字,利用回溯法,只对原数组进行修改,在递归完成后再修改回来。



```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        if (nums.empty()) return ans;
        backtarcking(nums, 0, ans);
        return ans;
    }
    void backtarcking(vector<int>&nums, int index, vector<vector<int>>& ans) {
        if (index == nums.size()) {
            ans.push_back(nums);
            return ;
        }
        for (int i = index; i < nums.size(); i++) {
            swap(nums[i], nums[index]);
            backtarcking(nums, index + 1, ans);
            swap(nums[i], nums[index]);
        }
    }
};
```





广度优先搜索（breadth-first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因
此需要用**先入先出**的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时
按照“广”的方向进行遍历的，也常常用来处理最短路径等问题。

这里要注意，深度优先搜索和广度优先搜索都可以处理可达性问题，即从一个节点开始是否
能达到另一个节点。因为深度优先搜索可以利用递归快速实现，很多人会习惯使用深度优先搜索
刷此类题目。实际软件工程中，笔者很少见到递归的写法，因为一方面难以理解，另一方面可能
产生栈溢出的情况；而用栈实现的深度优先搜索和用队列实现的广度优先搜索在写法上并没有太
大差异，因此使用哪一种搜索方式需要根据实际的功能需求来判断。



### 穷举搜索（exhaustive search）

穷举搜索的最大局限性在于它的效率低下

1. 如何产生所有可能解
2. 生成和处理的可能解数量

通常，如果可能解的数量随着问题规模而呈指数增长

### 特殊状态的枚举

 C++的标准库中提供了`next_permutation`这一函数，可以把n个元素共n种不同的排列生成出来 

又或者通过使用位运算，可以枚举从n个元素中取出k个的共$C_n^k$，种状态或是某个集合中的全部子集等。

### 剪枝

深度优先搜索时，有时早已很明确地知道从当前状态无论如何转移都不会存在解，这种情况下不再继续搜索而是直接跳过

## 动态规划（Dynamic Programming,DP）

解决有着彼此**重叠子问题**的问题。其解法并不是一遍遍地对彼此重叠的子问题求解，而是只对较小规模的子问题求解一次，然后把结果记录在一个表格中

最优化问题而言，问题必须具备所谓的**最优子结构（**optimal substructure），才能从子问题的局部最优解有效地构造出全局最优解。(对有些问题这个要求并不能完全满足,故有时需要引入一定的近似)。简单地说,问题能够分解成子问题来解决。

1. 动态规划和其它遍历算法(如深/广度优先搜索)都是将原问题拆成多个子问题然后求解,他们之间最本质的区别是,动态规划保存子问题的解,避免重复计算。
2. 动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，

动态规划问题的⼀般形式就是求最值。

求解动态规划的核⼼问题是穷举，找到状态转移方程

1. 在「重叠⼦问题」，需要「备忘录」或者「DP table」来优化穷举过程
2. 具备「最优⼦结构」，⼦问题间必须互相独⽴。
3. 空间压缩

#### 求解套路

1. 第一步：确定动归状态
2. 第二步：推导状态转移方程，理解：转移、决策；「容斥原理」
   dp数组如何初始化，确定遍历顺序；
3. 第三步：正确性证明，利用数学归纳法
4. 第四步：程序实现
5. 所谓的转移，把所有决定 $f(i, j)$ 最优值的状态，放入到决策过程中。

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

树形DP，数位DP，区间DP ，概率型DP，博弈型DP，状态压缩dp

###  基本动态规划

#### 509. 斐波那契数

> 该数列由 0 和 1 开始，后⾯的每⼀项数字都是前⾯两项数字的和。也就是：
>
> - F(0) = 0，F(1) = 1
> - F(n) = F(n - 1) + F(n - 2)，其中 n > 1

```cpp
class Solution {
public:
	int fib(int N) {
		if (N < 2) return N;
		return fib(N - 1) + fib(N - 2);
	}
};
```

时间复杂度：O(2^n)

1. dp[i]的定义为：第i个数的斐波那契数值是dp[i]
2. 状态转移⽅程 dp[i] = dp[i - 1] + dp[i - 2];

#### 70. 爬楼梯

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的⽅法可以爬到楼顶呢？



1. dp[i]： 爬到第i层楼梯，有dp[i]种⽅法
2. dp[i] = dp[i - 1] + dp[i - 2];



> 就是⼀步⼀个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种⽅法爬
> 到n阶楼顶。
>
> **完全背包问题**



```cpp
int climbStairs(int n) {
	vector<int> dp(n + 1, 0);
	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
			if (i - j >= 0) dp[i] += dp[i - j];
		}
	}
	return dp[n];
}
```

#### 62.不同路径

> ⼀个机器⼈位于⼀个 m x n ⽹格的左上⻆ （起始点在下图中标记为 “Start” ）。机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下⻆（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

动态规划

1. $dp[i][j]$  ：表示从（0 ，0）出发，到(i, j) 有$dp[i][j]$ 条不同的路径。
2. $dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$

数论⽅法

m，n的话，⽆论怎么⾛，⾛到右下的终点都需要 m + n - 2 步。

组合问题：m+n-2步中有n-1步向下

**求组合的时候，要防⽌两个int相乘溢出！**

```cpp
int uniquePaths(int m, int n) {
	long long numerator = 1; // 分⼦
	int denominator = m - 1; // 分⺟
	int count = m - 1;
	int t = m + n - 2;
	while (count--) {
		numerator *= (t--);
		while (denominator != 0 && numerator % denominator == 0) {
        	numerator /= denominator;
			denominator--;
		}
	}
	return numerator;
}
```



> ⼀个机器⼈位于⼀个 m x n ⽹格的左上⻆ （起始点在下图中标记为 “Start” ）。机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下⻆（在下图中标记为 “Finish” ）。**现在考虑⽹格中有障碍物**。那么从左上⻆到右下⻆将会有多少条不同的路径？



1. $dp[i][j] $：表示从（0 ，0）出发，到(i, j) 有$dp[i][j]$条不同的路径。

2. ```cpp
   if (obstacleGrid[i][j] == 0) { // 当(i, j)没有障碍的时候，再推导dp[i][j]
   	dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
   }
   ```

#### 343. 整数拆分

> 给定⼀个正整数 n，将其拆分为⾄少两个正整数的和，并使这些整数的乘积最⼤化。 返回你可以获得的最⼤乘积。
> 示例 1:
> 输⼊: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1。

动规
1. dp[i]：分拆数字i，可以得到的最⼤乘积为dp[i]。
2. dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

贪⼼

贪⼼，每次拆成n个3，如果剩下是4，则保留4，然后相乘。结论需要数学证明

```cpp
int integerBreak(int n) {
	if (n == 2) return 1;
	if (n == 3) return 2;
	if (n == 4) return 4;
	int result = 1;
	while (n > 4) {result *= 3;
		n -= 3;
	}
	result *= n;
	return result;
}
```

#### 96.不同的⼆叉搜索树

> 给定⼀个整数 n，求以 1 ... n 为节点组成的⼆叉搜索树有多少种？



1. dp[i] ： 1到i为节点组成的⼆叉搜索树的个数为dp[i]。
2. dp[i] += dp[以j为头结点左⼦树节点数量] * dp[以j为头结点右⼦树节点数量]
3. dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左⼦树节点数量，i-j 为以j为头结点右⼦树节点数量



#### [542.01 矩阵](https://leetcode-cn.com/problems/01-matrix/description/)

<details open="" style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><p style="margin-top: 0px; margin-bottom: 0.7em;"><a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;">depth-first-search</code></a><span>&nbsp;</span>|<span>&nbsp;</span><a href="https://leetcode.com/tag/breadth-first-search" title="https://leetcode.com/tag/breadth-first-search" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;">breadth-first-search</code></a></p></details>

> 给定一个由 `0` 和 `1` 组成的矩阵 `mat` ，请输出一个大小相同的矩阵，其中每一个格子是 `mat` 中对应位置元素到最近的 `0` 的距离。
>
> 两个相邻元素间的距离为 `1` 。

一般来说,因为这道题涉及到四个方向上的最近搜索，第一反应可能会是广度优先搜索。但是对于一个大小 O(mn) 的二维数组,对每个位置进行四向搜索,最坏情况的时间复杂度(即全是 1)会达到恐怖的 $O(m^2n^2)$。

使用一个 dp 数组做 memoization,使得广度优先搜索不会重复遍历相同位置;

另一种更简单的方法是,我们从左上到右下进行一次动态搜索,再从右下到左上进行一次动态搜索。两次动态搜索即可完成四个方向上的查找。




```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        if (mat.empty()) return {};
        int row = mat.size(), col = row ? mat[0].size() : 0;
        vector<vector<int>> dp(row, vector<int>(col, INT_MAX - 1));
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (mat[i][j] == 0) {
                    dp[i][j] = 0;
                } else {
                    if (i) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);
                    if (j) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);
                }
            }
        }
        for (int i = row - 1; i >= 0; i--) {
          for (int j = col - 1; j >= 0; j--) {
            if (mat[i][j] == 0) {
              dp[i][j] = 0;
            } else {
              if (i < row - 1) dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);
              if (j < col - 1) dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);
            }
          }
        }
        return dp;

    }
};
```



#### [221.最大正方形](https://leetcode-cn.com/problems/maximal-square/description/)

<details open="" style="color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><slot name="user-agent-default-slot" id="details-content"><p style="margin-top: 0px; margin-bottom: 0.7em;"><a href="https://leetcode.com/tag/dynamic-programming" title="https://leetcode.com/tag/dynamic-programming" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;">dynamic-programming</code></a></p></slot></details>

> 在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。



1. $dp[i][j]$ ：表示以i,j为右下角的只包含1的最大正方形面积
2. 如果当前位置是 0,那么 $dp[i][j]$ 即为 0;
   设 $dp[i][j] = k^2$ ,其充分条件为 $dp[i-1][j-1]$、$dp[i][j-1]$ 和 $dp[i-1][j]$ 的值必须都不小于 $(k − 1)/2$ ,



```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int row = matrix.size(), col = matrix[0].size();
        int ans = 0;
        vector<vector<int>> cnt(row, vector<int>(col, 0));
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (!i || !j || matrix[i][j] == '0') {
                    cnt[i][j] = matrix[i][j] == '0' ? 0 : 1;
                } else {
                    cnt[i][j] = min(min(cnt[i][j - 1], cnt[i - 1][j]), cnt[i - 1][j - 1]) + 1;
                }
                ans = max(ans, cnt[i][j] * cnt[i][j]);

            }
        }
        /*
        for (int j = 0; j < col; ++j) cnt[0][j] = matrix[0][j] == '1';
        for (int i = 1; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                cnt[i][j] = matrix[i][j] == '1' ? cnt[i - 1][j] + 1 : 0;
            }
        }
        for (int i = 0; i < row; ++i) {
            deque<int> q;
            int l = 0;
            for (int j = 0; j < col; ++j) {
                while(!q.empty() && cnt[i][q.back()] > cnt[i][j]) q.pop_back();
                q.push_back(j);
                while (j - l >= 0 && j - l + 1 > cnt[i][q.front()]) {
                    ++l;
                    if (q.front() < l) q.pop_front();
                }
                ans = max(ans, (j - l + 1) * (j - l + 1));
            }
        }
        */
        return ans;

    }
};
// @lc code=end

```





### 子序列问题

<img src='https://code-thinking.cdn.bcebos.com/pics/动态规划-子序列问题总结.jpg' width=500 alt=''> </img>

#### 300.最长递增子序列

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
> 示例 1：
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

1. 定义：**dp[i]表示i之前包括i的最长上升子序列**。

2. 状态转移方程：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

   位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

3. 初始化：每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1.



```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (!nums.size()) return 0;
        if (nums.size() == 1) return 1;
        int *arr = new int[nums.size()];
        int head = 0, tail = -1;
        for (int i = 0; i < nums.size(); i++) {
            if (tail + 1 == head || nums[i] > arr[tail]) {
                arr[++tail] = nums[i];
            } else {
                arr[getIdx(arr, 0, tail, nums[i])] = nums[i];
            }
        }
        return tail - head + 1;
    }
    int getIdx(int *arr, int l, int r, int k) {
        while (l < r) {
            int mid = (l + r) >> 1;
            if (arr[mid] >= k) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n <= 1) return n;
    vector<int> dp;
    dp.push_back(nums[0]);
    for (int i = 1; i < n; ++i) {
        if (dp.back() < nums[i]) {
            dp.push_back(nums[i]);
        } else {
            auto itr = lower_bound(dp.begin(), dp.end(), nums[i]);
            *itr = nums[i];
        }
    }
    return dp.size();
}
```





#### 674. 最长连续递增序列

> 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

1. **dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]**。
2. if (nums[i] > nums[j]) dp[i + 1] = dp[i] + 1;
3. 初始化：每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1.

**贪心**

遇到nums[i + 1] > nums[i]的情况，count就++，否则count为1，记录count的最大值

#### 718. 最长重复子数组

> 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
>
> 输入：
> A: [1,2,3,2,1]
> B: [3,2,1,4,7]
> 输出：3
>
> 解释：
> 长度最长的公共子数组是 [3, 2, 1] 。
>
> **元素连续**

1. $dp[i][j] $：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为$dp[i][j]$。
2. $dp[i][j] = dp[i - 1][j - 1] + 1$;

```cpp
	for (int i = 1; i <= A.size(); i++) {
            for (int j = B.size(); j > 0; j--) {
                if (A[i - 1] == B[j - 1]) {
                    dp[j] = dp[j - 1] + 1;
                } else dp[j] = 0; // 注意这里不相等的时候要有赋0的操作 
                if (dp[j] > result) result = dp[j];
            }
        }
```

#### 1143.最长公共子序列

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
>
> 输入：text1 = "abcde", text2 = "ace"
> 输出：3
> 解释：最长公共子序列是 "ace"，它的长度为 3
>
> **元素无需连续**



1. $dp[i][j]$：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为$dp[i][j]$

2. ```cpp
   if (text1[i - 1] == text2[j - 1]) {
       dp[i][j] = dp[i - 1][j - 1] + 1;
   } else {
       dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
   }
   ```

#### 1035.不相交的线

> 我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。
>
> 现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。
>
> 以这种方法绘制线条，并返回我们可以绘制的最大连线数。
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5PlFCN8X5f6P5ur7tgO8v7UvfO8dUlurKQZk6O9aND4MB5OEWFHyXmhqZS1HOx3sS0HKtfOBuL6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



直线不能相交，意味着这个子序列不能改变相对顺序，**其实就是求两个字符串的最长公共子序列的长度！**

#### 53. 最大子序和

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

找最大的连续子序列，就应该找每一个i为终点的连续最大子序列。
1. **dp[i]：包括下标i之前的最大连续子序列和为dp[i]**。
2. dp[i] = max(dp[i - 1] + nums[i], nums[i]);

贪心解法

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

```cpp
	for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count;
            }
            if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
```









### 字符串编辑

#### 392.判断子序列

> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

1. **$dp[i][j]$ 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为$dp[i][j]$**。
2. if (s[i - 1] == t[j - 1])
   t中找到了⼀个字符在s中也出现了：$dp[i][j] = dp[i - 1][j - 1] + 1;$
   if (s[i - 1] != t[j - 1])
   相当于t要删除元素，继续匹配：$dp[i][j] = dp[i][j - 1];$



#### 115.不同的⼦序列

> 给定⼀个字符串 s 和⼀个字符串 t ，计算在 s 的⼦序列中 t 出现的个数。
> 字符串的⼀个 ⼦序列 是指，通过删除⼀些（也可以不删除）字符且不⼲扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的⼀个⼦序列，⽽ "AEC" 不是）

如果不是⼦序列，⽽是要求连续序列的，那就可以考虑⽤KMP。

1. $dp[i][j]$ ：以i-1为结尾的s⼦序列中出现以j-1为结尾的t的个数为 $dp[i][j]$。

#### 583. 两个字符串的删除操作

> 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最⼩步数，每步可以删除任意⼀个字符串中的⼀个字符。



#### [650.只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/description/)

> 最初记事本上只有一个字符 `'A'` 。你每次可以对这个记事本进行两种操作：
>
> - `Copy All`（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
> - `Paste`（粘贴）：粘贴 **上一次** 复制的字符。
>
> 给你一个数字 `n` ，你需要使用最少的操作次数，在记事本上输出 **恰好** `n` 个 `'A'` 。返回能够打印出 `n` 个 `'A'` 的最少操作次数。

动态规划,这里需要乘除法来计算位置

其中位置 i 表示延展到长度 i 的最少操作次数。对于每个位置j,如果 j 可以被 i 整除,那么长度 i 就可以由长度 j 操作得到,其操作次数等价于把一个长度为 1 的 A 延展到长度为 i/j。

递推公式 dp[i] = dp[j] + dp[i/j]。

```cpp
 class Solution {
public:
    int minSteps(int n) {
        vector<int> dp(n + 5, 0);
        for (int i = 2; i <= n; i++) {
            dp[i] = i;
            for (int j = 2; j * j <= n; j++) {
                if (i % j) continue;
                dp[i] = min(dp[j] + dp[i / j], dp[i]);
            }
        }
        return dp[n];
    }
};
```

#### [10.正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/description/)

> 给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。
>
> - `'.'` 匹配任意单个字符
> - `'*'` 匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。



其中 $dp[i][j]$ 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。

字符、星号,点号,分情况讨论

```cpp
class Solution {
 public:
  bool isMatch(string s, string p) {
    int m = s.size(), n = p.size();
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
    dp[0][0] = true;
    for (int i = 1; i < n + 1; ++i) {
      if (p[i - 1] == '*') {
        dp[0][i] = dp[0][i - 2];
      }
    }
    for (int i = 1; i < m + 1; ++i) {
      for (int j = 1; j < n + 1; ++j) {
        if (p[j - 1] == '.') {
          dp[i][j] = dp[i - 1][j - 1];
        } else if (p[j - 1] != '*') {
          dp[i][j] = dp[i - 1][j - 1] && p[j - 1] == s[i - 1];
        } else if (p[j - 2] != s[i - 1] && p[j - 2] != '.') {
          dp[i][j] = dp[i][j - 2];
        } else {
          dp[i][j] = dp[i][j - 1] || dp[i - 1][j] || dp[i][j - 2];
        }
      }
    }
    return dp[m][n];
  }
};
// @lc code=end
```





###  背包问题

**背包问题的理论基础重中之重是01背包**

而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。



![416.分割等和子集1](https://img-blog.csdnimg.cn/20210117171307407.png)

* 
* [动态规划：分割等和子集可以用01背包！](https://mp.weixin.qq.com/s/sYw3QtPPQ5HMZCJcT4EaLQ)
* [动态规划：最后一块石头的重量 II](https://mp.weixin.qq.com/s/WbwAo3jaUaNJjvhHgq0BGg)
* [动态规划：目标和！](https://mp.weixin.qq.com/s/2pWmaohX75gwxvBENS-NCw)
* [动态规划：一和零！](https://mp.weixin.qq.com/s/x-u3Dsp76DlYqtCe0xEKJw)
* [动态规划：给你一些零钱，你要怎么凑？](https://mp.weixin.qq.com/s/PlowDsI4WMBOzf3q80AksQ)
* [动态规划：Carl称它为排列总和！](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)
* [动态规划：以前我没得选，现在我选择再爬一次！](https://mp.weixin.qq.com/s/e_wacnELo-2PG76EjrUakA)
* [动态规划： 给我个机会，我再兑换一次零钱](https://mp.weixin.qq.com/s/dyk-xNilHzNtVdPPLObSeQ)
* [动态规划：一样的套路，再求一次完全平方数](https://mp.weixin.qq.com/s/VfJT78p7UGpDZsapKF_QJQ)
* [动态规划：单词拆分](https://mp.weixin.qq.com/s/3Spx1B6MbIYjS8YkVbByzA)
* [听说背包问题很难？ 这篇总结篇来拯救你了](https://mp.weixin.qq.com/s/ZOehl3U1mDiyOQjFG1wNJA)

<img src='https://code-thinking.cdn.bcebos.com/pics/动态规划-背包问题总结.png' width=500 alt='背包问题大纲'> </img>



#### 背包递推公式

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：

* [动态规划：416.分割等和子集](https://mp.weixin.qq.com/s/sYw3QtPPQ5HMZCJcT4EaLQ)
* [动态规划：1049.最后一块石头的重量 II](https://mp.weixin.qq.com/s/WbwAo3jaUaNJjvhHgq0BGg)

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：

* [动态规划：494.目标和](https://mp.weixin.qq.com/s/2pWmaohX75gwxvBENS-NCw)
* 求组合数：[动态规划：518. 零钱兑换 II](https://mp.weixin.qq.com/s/PlowDsI4WMBOzf3q80AksQ)
* 求排列数：[动态规划：377.组合总和Ⅳ](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)
* [动态规划：70. 爬楼梯进阶版（完全背包）](https://mp.weixin.qq.com/s/e_wacnELo-2PG76EjrUakA)

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：

* [动态规划：474.一和零](https://mp.weixin.qq.com/s/x-u3Dsp76DlYqtCe0xEKJw)

问装满背包所有物品的最小个数：dp[j] =  min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：

* 求最小数：[动态规划：322.零钱兑换](https://mp.weixin.qq.com/s/dyk-xNilHzNtVdPPLObSeQ)
* [动态规划：279.完全平方数](https://mp.weixin.qq.com/s/VfJT78p7UGpDZsapKF_QJQ)

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

``背包九讲``

#### 01背包问题

> 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 $C_i$ ，得到的
> 价值是 $W_i$ 。求解将哪些物品装入背包可使价值总和最大。
>
> ![image-20210925205706439](/Image/B1.算法设计-photo/image-20210925205706439.png)

**暴力的解法**

每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。

**动态规划**

1. $F[i][v]$ 表示从下标为$[0-i]$的物品里任意取，放进容量为$v$的背包，可以获得
   的最大价值。递归公式：$F[i, v] = \max\left\{F[i − 1, v], F[i − 1, v − C_i] + W_i \right\}$
2. 从 $F[i][v]$ 的定义出发，如果背包容量v为0的话，即 $F[i][0]$，无论是选取哪些物品，背包价值总和一定为0。

**滚动数组优化**

滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

1. $F[v]$ 为 容量为v的背包所背的最大价值
2. 递归公式：$F[v] = \max(F[v], F[v - C_i] + W_i);$

**一个常数优化**

for i $←$ 1 to $N$
	for v $←$ V to $C_i$
二重循环的下限可以改进。它可以被优化为：（提示：使用二维的转移方程）
for i $←$ 1 to $N$
	for v $←$ $V$ to $\max(V − Σ^N_i W_i , C_i )$

def ZeroOnePack(F, C, W )
	for v ← V to C
		F [v] ← max(F [v], F [v − C] + W )

**初始化的细节问题**

1. **要求恰好装满背包的最优解。**，那么在初始化时除了 $F[0]$ 为 0 ，其它$F [1..V ]$ 均设为 $−∞$ ，
2. **没有要求必须把背包装，而是只希望价格尽量大。**初始化时应该将 $F[0..V ]$全部设为 0 。

初始化的 F数组事实上就是在没有任何物品可以放入背包时的合法状态。

如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 $-∞$ 了。

如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为 0了。



#### 完全背包

> 有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。放入第 $i$ 种物品
的费用是 $C_i$ ，价值是 $W_i$ 。求解：将哪些物品装入背包，可使这些物品的耗费的费用总
和不超过背包容量，且价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。**(也就是可以放入背包多次）**

1. 令 $F[i, v]$ 表示前 i 种物品恰放入一个容量为 v 的背包的最大权值。
2. 递推公式：$F[i, v] = \max{F [i − 1, v − kC_i ] + kW_i \big| 0 ≤ kC_i ≤ v}$
3. 递推公式：$F[v] = \max(F[v], F[v - C_i] + W_i);$

跟 01 背包问题一样有 $O(VN )$ 个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态 F [i, v] 的时间是 $O( \frac{v}{C_i} )$ ，总的复杂度可以认为是 $O(NV \sum\frac{v}{C_i} )$

**一个简单有效的优化**

两件物品 i 、 j 满足 $C_i ≤ C_j$且 $W_i ≥ W_j$ ，则将可以将物品 j 直接去掉，不用考虑。$O(N ^2) $实现

**转化为 01背包问题求解**

考虑到第 i 种物品最多选 $\lfloor V /C_i \rfloor$ 件，于是可以把第 i 种物品转化为 $\lfloor V /C_i \rfloor$件费用及价值均不变的物品，然后求解这个 01 背包问题。

**$O(V N )$ 的算法**

​	F [0..V ] ←0
​	for i ← 1 to N
​		for v ← $C_i$ to V
​			F [v] ←$\max(F[v], F[v - C_i] + W_i)$

def CompletePack(F, C, W )
	for v ← C to V
		F [v] ← max{F [v], f [v − C] + W }

两层 for 循环的次序可以颠倒。

1. 递推公式：$F [i, v] = \max(F [i − 1, v], F [i, v − C_i ] + W_i )$
2. 递推公式：$F[v] = \max(F[v], F[v - C_i] + W_i);$



#### 多重背包

> 有N种物品和一个容量为V 的背包。第i种物品最多有 $M_i$ 件可用，每件耗费的空间是 $C_i$，价值是 $W_i$  。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

因为对于第 i 种物品有 $M_i + 1$ 种策略：取 0 件，取 1 件……取 $M_i$ 件。

$F [i ， v] = max{F [i − 1, v − k ∗ C_i ] + k ∗ W_i \big| 0 ≤ k ≤ M_i }$

**转变为01背包**

每件物品最多有 $M_i$ 件可用，把 $M_i$ 件摊开，其实就是一个01背包问题。

时间复杂度：O(m * n * k)  ，m：物品种类个数，n背包容量，k单类物品数量

**二进制优化**

把每种物品的数量，打包成一个个独立的包。为是分拆为各个包最后可以组成一个完整背包

把第 i 种物品拆成费用为 $C_i 2^k$ 、价值为 $W_i 2^k $的若干件物品。$1$, $2$, $2^2$ ,. . ., $2^{k−1}$ , $M_i − 2^k + 1$

因为，不管最优策略选几件第 i 种物品，其件数写成二进制后，总可以表示成若干个 $2^k$ 件物品的和。这样一来就把每种物品拆成 $O(\log M_i)$ 件物品。

**伪代码**

def MultiplePack(F ,C,W ,M )
	if C · M ≥ V
		CompletePack(F ,C,W )
			return
	k ← 1
	while k < M
		ZeroOnePack(kC,kW )
		M ←M − k
		k ← 2k
ZeroOnePack(C · M ,W · M )

**单调队列优化**



#### 混合三种背包问题

> 如果将前面 1 、 2 、 3 中的三种背包问题混合起来。也就是说，有的物品只可以取一次（ 01 背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？

**01 背包与完全背包的混合**

for i ← 1 to N
	if 第 i 件物品属于 01 背包
		for v ← V to $C_i$
			F [v] ← max(F [v], F [v − $C_i$ ] + $W_i$ )
	else if 第 i 件物品属于完全背包
		for v ← $C_i$ to V
			F [v] ← max(F [v], F [v − $C_i$ ] + $W_i$ )

**再加上多重背包**

for i ← 1 to N
	if 第 i 件物品属于 01 背包
		ZeroOnePack(F ,$C_i$ ,$W_i$ )
	else if 第 i 件物品属于完全背包
		CompletePack(F ,$C_i$ ,$W_i$ )
	else if 第 i 件物品属于多重背包
		MultiplePack(F ,$C_i$ ,$W_i$ ,N i )

#### 二维费用的背包问题

> 二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。
> 设第 i 件物品所需的两种费用分别为 $C_i$ 和 $D_i$ 。两种费用可付出的最大值（也即两
> 种背包容量）分别为 V 和 U 。物品的价值为 $W_i$ 。

费用加了一维，只需状态也加一维即可。

1. 设 $F [i, v, u]$ 表示前 i 件物品付出两种费用分别为 v 和 u 时可获得的最大价值。
2. 状态转移方程：$F [i, v, u] = \max{F[i − 1, v, u], F[i − 1, v − C_i , u − D_i ] + W_i }$

**物品总个数的限制**

有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。

事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1 ，可以付出的最大件数费用为 U 。换句话说，设 $F [v, u]$ 表示付出费用 v 、最多选 u 件时可得到的最大价值，则根据物品的类型（ 01 、完全、多重）用不同的方法循环更新，最后在f [0 . . . V, 0 . . . U ] 范围内寻找答案。

**复整数域上的背包问题**

另一种看待二维背包问题的思路是：将它看待成复整数域上的背包问题。也就是说，背包的容量以及每件物品的费用都是一个复整数。而常见的一维背包问题则是自然数域上的背包问题。所以说，一维背包的种种思想方法，往往可以应用于二维背包问题的求解中，因为只是数域扩大了而已。

#### 分组的背包问题

> 有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 $C_i$ ，价值是 $W_i$ 。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

每组物品有若干种策略：是选择本组的某一件，还是一件都不选。**定义“泛化物品”的概念**

1.  $F [k, v]$ 表示前 k 组物品花费费用 v 能取得的最大权值
2. $F [k, v] = \max{F [k − 1, v], F [k − 1, v − C_i ] + W_i \big| item \ i \ ∈ group \ k}$

**伪代码**

for k ← 1 to K
	for v ← V to 0
		for all item i in group k
			F [v] ← max{F [v], F [v − Ci ] + Wi }

#### 有依赖的背包问题

> 简化的问题
>
> 这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j ，表示若选物品 i ，则必须选物品 j 。

所有的物品由若干主件和依赖于每个主件的一个附件集合组成。

按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 n 个附件，则策略有 $2^n + 1$ 个，为指数级。

考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于分组的背包问题中的一个物品组。但

> 更一般的问题是：依赖关系以图论中“森林” 的形式给出。也就是说，主件的附件仍然可以具有自己的附件集合。限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。

解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。

这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值

#### 泛化物品

> 考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的
> 费用而变化。这就是泛化物品的概念。
>
> 在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V 中的整数的函数 h ，当分配给它的费用为 v 时，能得到的价值就是 h(v) 。

一个费用为 c 价值为 w 的物品，

- 如果它是 01 背包中的物品，那么把它看成泛化物品，它就是除了 $h(c) = w $外，其它函数值都为 0 的一个函数。
- 如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 $h(v) = w · \frac{v}{c} $，其它函数值均为 0 。
- 如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函数有 $h(v) = w ·\frac{v}{c} $ 仅当 v 被 c 整除且 vc ≤ n ，其它情况函数值均为 0 。
- 一个物品组可以看作一个泛化物品 h 。对于一个 0 . . . V 中的 v ，若物品组中不存在费用为 v 的物品，则 h(v) = 0 ，否则 h(v) 取值为所有费用为 v 的物品的最大价值。 
- 有依赖的背包问题中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。

**泛化物品的和**

如果给定了两个泛化物品 h 和 l ，要用一定的费用从这两个泛化物品中得到最大的价值。

对于一个给定的费用 v ，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于 0. . .V 中的每一个整数 v ，可以求得费用v 分配到 h 和 l 中的最大价值 f (v) 。也即 

$f (v) = \max\left\{h(k) + l(v − k) | 0 ≤ k ≤ v\right\}$

可以看到，这里的 f 是一个由泛化物品 h 和 l 决定的定义域为 0. . .V 的函数，也就是说， f 是一个由泛化物品 h 和 l 决定的泛化物品。

#### 背包问题问法的变化

1. 以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值。
2. 求解最多可以放多少件物品或者最多可以装满多少背包的空间。
3. 如果要求的是“总价值最小”“总件数最小”，只需将状态转移方程中的 max 改成 min 即可。

**输出方案**

一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。

以 01 背包为例，方程为 $F [i, v] = \max{F [i − 1, v], F [i − 1, v − C_i ] + W_i } $。再用
一个数组 $G[i, v] $，设 $G[i, v] = 0$ 表示推出$ F [i, v] $的值时是采用了方程的前一项（也即
$F [i, v] = F [i − 1, v] ）$， $G[i, v] = 1$ 表示采用了方程的后一项。注意这两项分别表示了两
种策略：未选第 i 个物品及选了第 i 个物品。

i ←N
v ← V
	while i > 0
		if G[i, v] = 0
			print 未选第 i 项物品
		else if G[i, v] = 1
			print 选了第 i 项物品
			$v ← sv − C_i$
		i ← i − 1

另外，采用方程的前一项或后一项也可以在输出方案的过程中根据 $F [i, v]$ 的值实时地求
出来。也即，不须纪录 G 数组，将上述代码中的 $G[i, v] = 0$ 改成 $F [i, v] = F [i − 1, v] ，
G[i, v] = 1$ 改成 $F[i, v] = F [i − 1][v − C_i ] + W_i $ 也可。

**输出字典序最小的最优方案**

> 字典序最小”的意思是 1 . . . N 号物品的选择方案排列出来以后字典序最小。

如果存在一个选了物品 1 的最优方案，那么答案一定包含物品 1 ，原问题转化为一个背包容量为 $V −C_1$ ，物品为 2 . . . N 的子问题。反之，如果答案不包含物品 1 ，则转化成背包容量仍为 V ，物品为 2 . . . N的子问题。

不管答案怎样，子问题的物品都是以 i . . . N 而非前所述的 1 . . . i 的形式来定义的

**求方案总数**

> 对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。

一般只需将状态转移方程中的 max 改成 sum 即可。

事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。

**最优方案的总数**

最优方案是指物品总价值最大的方案。

结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：$F [i, v]$ 代表该状态的最大价值， $G[i, v]$ 表示这个子问题的最优方案的总数，则在求 $F [i, v]$ 的同时求 $G[i, v]$ 的伪代码如下：

$G[0, 0] ← 1$
for i ← 1 to N
	for v ← 0 to V
		$F[i, v] ← \max\left\{F [i − 1, v], F [i − 1, v − C_i ] + W_i \right\}$
		$G[i, v] ← 0$
		if F [i, v] = F [i − 1, v]
			$G[i, v] ← G[i, v] + G[i − 1][v]$
		if F [i, v] = F [i − 1, v − C_i ] + W_i
			$G[i, v] ← G[i, v] + G[i − 1][v − C_i ]$



**求次优解、第 K 优解**

第 K 优解则比求最优解的复杂度上多一个系数 K 。

其基本思想是，将每个状态都表示成有序队列，将状态转移方程中的 max/min 转化成有序队列的合并。

$ F[i, v] = \max\{F [i − 1, v], F [i − 1, v − C_i ] + W_i \}$。如果要求第 K 优解，那么状态 F [i, v] 就应该是一个大小为 K 的队列 $F [i, v, 1 . . . K]$ 。其中 $F [i, v, k]$ 表示前 i 个物品中，背包大小为 v 时，第 k 优解的值。这里也可以简单地理解为在原来的方程中加了一维来表示结果的优先次序。显然$f [i, v, 1 . . . K]$ 这 K 个数是由大到小排列的，所以它可看作是一个有序队列。

然后原方程就可以解释为： $F [i, v]$ 这个有序队列是由 $F [i − 1, v] 和 F [i − 1,v −
C_i ] + W_i $这两个有序队列合并得到的。前者 $F [i − 1][V ]$ 即 $F [i − 1, v, 1 . . . K]$ ，后者
$F [i − 1,v − C_i ] + W_i$ 则理解为在 $F [i − 1,v − C_i , 1 . . . K]$ 的每个数上加上 $W_i$ 后得到的
有序队列。合并这两个有序队列并将结果的前 K 项储存到 $f [i, v, 1 . . . K] $中的复杂度是
$O(K)$ 。最后的第 K 优解的答案是 $F [N, V, K] $。总的时间复杂度是 $ O(V N K) $。

为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为 K 的数组，并在这个数组中有序地保存该状态可取到的前 K 个最优值。那么，对于任两个状态的max 运算等价于两个由大到小的有序队列的合并。
另外还要注意题目对于“第 K 优解”的定义，是要求将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。



### 分割类型题

#### [91.解码方法](https://leetcode-cn.com/problems/decode-ways/description/)

> 一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：
>
> ```
> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26
> ```
>
> 要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：
>
> - `"AAJF"` ，将消息分组为 `(1 1 10 6)`
> - `"KJF"` ，将消息分组为 `(11 10 6)`
>
> 注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。



```cpp
class Solution {
public:
    int numDecodings(string s) {
        int length = s.length();
        if (!length) return 0;
        int prev = s[0] - '0';
        if (!prev) return 0;
        if (length == 1) return 1;
        vector<int> dp(length + 5, 0);
        dp[1] = dp[0] = 1;
        for (int i = 2; i <= length; i++) {
            int cur = s[i - 1] - '0';
            if (!cur && (prev == 0 || prev > 2)) return 0;
            if ((prev == 1) || (prev == 2 && cur < 7)) {
                if (cur) {
                    dp[i] = dp[i - 1] + dp[i - 2];
                } else {
                    dp[i] = dp[i - 2];
                }
            } else {
                dp[i] = dp[i - 1];
            }
            prev = cur;
        }
        return dp[length];
    }
};
// @lc code=end

```





#### 416. 分割等和⼦集

> 给定⼀个只包含正整数的⾮空数组。是否可以将这个数组分割成两个⼦集，使得两个⼦集的元素和相等。

只要找到集合⾥能够出现 sum / 2 的⼦集总和，就算是可以分割成两个相同元素和⼦集

**01背包问题**

- 背包的体积为sum / 2
- 背包要放⼊的商品（集合⾥的元素）重量为 元素的数值，价值也为元素的数值
- 背包如何正好装满，说明找到了总和为 sum / 2 的⼦集。
- 背包中每⼀个元素是不可重复放⼊。

**算法**

1. dp[i]表示 背包总容量是i，最⼤可以凑成i的⼦集总和为dp[i]。
2. dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);



#### 1049. 最后⼀块⽯头的重量 II

> 有⼀堆⽯头，每块⽯头的重量都是正整数。
> 每⼀回合，从中选出任意两块⽯头，然后将它们⼀起粉碎。假设⽯头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 1. 如果 x == y，那么两块⽯头都会被完全粉碎；
>
> 2. 如果 x != y，那么重量为 x 的⽯头将会完全粉碎，⽽重量为 y 的⽯头新重量为 y-x。
>
> 最后，最多只会剩下⼀块⽯头。返回此⽯头最⼩的可能重量。如果没有⽯头剩下，就返回 0。

尽量让⽯头分成重量相同的两堆，相撞之后剩下的⽯头最⼩，这样就化解成01背包问题

1. dp[j]表示容量为j的背包，最多可以背dp[j]这么重的⽯头。
2. dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);

#### 494. ⽬标和

> 给定⼀个⾮负整数数组，a1, a2, ..., an, 和⼀个⽬标数，S。现在你有两个符号 + 和 -。对于数组中的任意⼀个整数，你都可以从 + 或 -中选择⼀个符号添加在前⾯。
>
> 返回可以使最终数组和为⽬标数 S 的所有添加符号的⽅法数。

既然为target，那么就⼀定有 left组合 - right组合 = target。

left + right等于sum，⽽sum是固定的。

left - (sum - left) = target -> left = (target + sum)/2 。

**回溯算法**

组合问题

**动态规划**

假设加法的总和为x，那么减法对应的总和就是sum - x。问题就转化为，装满容量为x背包，有⼏种⽅法。

1. dp[j] 表示：填满j（包括j）这么⼤容积的包，有dp[i]种⽅法
2. dp[j] += dp[j - nums[i]]

```cpp
int findTargetSumWays(vector<int>& nums, int S) {
	int sum = 0;
	for (int i = 0; i < nums.size(); i++) sum += nums[i];
	if (S > sum) return 0; // 此时没有⽅案
	if ((S + sum) % 2 == 1) return 0; // 此时没有⽅案
	int bagSize = (S + sum) / 2;
	vector<int> dp(bagSize + 1, 0);
	dp[0] = 1;
	for (int i = 0; i < nums.size(); i++) {
		for (int j = bagSize; j >= nums[i]; j--) {
			dp[j] += dp[j - nums[i]];
		}
	}
	return dp[bagSize];
}
```

#### 474.⼀和零

> 给你⼀个⼆进制字符串数组 strs 和两个整数 m 和 n 。
> 请你找出并返回 strs 的最⼤⼦集的⼤⼩，该⼦集中 最多 有 m 个 0 和 n 个 1 。
> 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 ⼦集 。
>
> 示例 1：
> 输⼊：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
> 输出：4
> 解释：最多有 5 个 0 和 3 个 1 的最⼤⼦集是 {"10","0001","1","0"} ，因此答案是 4 。
> 其他满⾜题意但较⼩的⼦集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满⾜题意，因为它含 4个 1 ，⼤于 n 的值 3 。

⽽m 和 n相当于是⼀个背包，两个维度的背包。

1. $dp[i][j]$：最多有i个0和j个1的strs的最⼤⼦集的⼤⼩为$dp[i][j]$。
2. $dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)$
   strs⾥的字符串有zeroNum个0，oneNum个1。

```cpp
class Solution {
public:
int findMaxForm(vector<string>& strs, int m, int n) {
	vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
	for (string str : strs) { // 遍历物品
		int oneNum = 0, zeroNum = 0;
		for (char c : str) {
			if (c == '0') zeroNum++;
			else oneNum++;
		}
		for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
			for (int j = n; j >= oneNum; j--) {
				dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
			}
		}
	}
	return dp[m][n];
}
};
```



#### 518. 零钱兑换 II

> 给定不同⾯额的硬币和⼀个总⾦额。写出函数来计算可以凑成总⾦额的硬币组合数。假设每⼀种⾯额的硬币有⽆限个。
>
> 输⼊: amount = 5, coins = [1, 2, 5]
> 输出: 4
> 解释: 有四种⽅式可以凑成总⾦额:
> 5=5
> 5=2+2+1
> 5=2+1+1+1
> 5=1+1+1+1+1

组合不强调元素之间的顺序，排列强调元素之间的顺序。

1. dp[j]：凑成总⾦额j的货币组合数为dp[j]
2. dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。

```cpp
for (int i = 0; i < coins.size(); i++) { // 遍历物品
	for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
		dp[j] += dp[j - coins[i]];
	}
}
//coins[0] = 1，coins[1] = 5。
//这种遍历顺序中dp[j]⾥计算的是组合数！

for (int j = 0; j <= amount; j++) { // 遍历背包容量
	for (int i = 0; i < coins.size(); i++) { // 遍历物品
	if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
	}
}

//背包容量的每⼀个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。
//此时dp[j]⾥算出来的就是排列数！
```



**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**
**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**

#### 139.单词拆分

> 给定⼀个⾮空字符串 s 和⼀个包含⾮空单词的列表 wordDict，判定 s 是否可以被空格拆分为⼀个或多个在字典中出现的单词。
> 说明：
> 拆分时可以重复使⽤字典中的单词。
> 你可以假设字典中没有重复的单词。
> 示例 1：
> 输⼊: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

回溯算法

枚举分割所有字符串，判断是否在字典⾥出现过。

```cpp
class Solution {
private:
bool backtracking (const string& s,
const unordered_set<string>& wordSet,
vector<int>& memory,
int startIndex) {
if (startIndex >= s.size()) {
return true;
}
// 如果memory[startIndex]不是初始值了，直接使⽤memory[startIndex]的结果
if (memory[startIndex] != -1) return memory[startIndex];
for (int i = startIndex; i < s.size(); i++) {
string word = s.substr(startIndex, i - startIndex + 1);
if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet,
memory, i + 1)) {
memory[startIndex] = 1; // 记录以startIndex开始的⼦串是可以被拆分的
return true;
}
}
memory[startIndex] = 0; // 记录以startIndex开始的⼦串是不可以被拆分的
return false;
}
public:
bool wordBreak(string s, vector<string>& wordDict) {
unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
vector<int> memory(s.size(), -1); // -1 表示初始化状态
return backtracking(s, wordSet, memory, 0);
}
```



背包问题

单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

1. dp[i] : 字符串⻓度为i的话，dp[i]为true，表示可以拆分为⼀个或多个在字典中出现的单词。
2. if([j, i] 这个区间的⼦串出现在字典⾥ && dp[j]是true) 那么 dp[i] = true。

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (wordSet.find(s.substr(j, i - j)) != wordSet.end() && dp[j] == true) {
                    dp[i] = true;
                    break;
                }
            }

        }
        return dp[s.size()];
    }
};
```

#### 划分数

> 有 n个无 区别的 物品，将它们 划分成不超过m组 ，求出划分方法数模M的余数





多重集组合数
有《 种物品，第 z 种 物品有 a, ■个。不同 种类的 物品可 以互相 区分但相同种类的无 法区分。从
这些物品 中取出 w 个的话 ，有 多少种 取法？ 求出方 案数模 Af 的 余数。

### 股票交易

<img src='https://code-thinking.cdn.bcebos.com/pics/股票问题总结.jpg' width=500 alt='股票问题总结'> </img>



#### 121. 买卖股票的最佳时机

> 给定⼀个数组 prices ，它的第 i 个元素 prices[i] 表示⼀⽀给定股票第 i 天的价格。
> 你只能选择 某⼀天 买⼊这只股票，并选择在 未来的某⼀个不同的⽇⼦ 卖出该股票。设计⼀个算法来计算你所能获取的最⼤利润。
> 返回你可以从这笔交易中获取的最⼤利润。如果你不能获取任何利润，返回 0 。

**股票只能买卖一次，问最大利润**。

【贪心解法】

取最左最小值，取最右最大值，那么得到的差值就是最大利润，代码如下：

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
};
```

【动态规划】

1. $dp[i][0]$ 表示第i天持有股票所得现金。

   $dp[i][1]$ 表示第i天不持有股票所得现金。

2. 如果第i天持有股票即$dp[i][0]$， 那么可以由两个状态推出来

   * 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：$dp[i - 1][0]$
   * 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]
     所以$dp[i][0] = max(dp[i - 1][0], -prices[i])$;

   如果第i天不持有股票即$dp[i][1]$， 也可以由两个状态推出来

   * 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：$dp[i - 1$][1]
   * 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：$prices[i] + dp[i - 1][0]$
     所以 $dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])$;

代码如下：

```C++
// 版本一
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```

使用滚动数组，代码如下：

```C++
// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```


#### 122.买卖股票的最佳时机II

>给定⼀个数组，它的第 i 个元素是⼀⽀给定股票第 i 天的价格。
>设计⼀个算法来计算你所能获取的最⼤利润。你可以尽可能地完成更多的交易（多次买卖⼀⽀股票）。
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**可以多次买卖股票，问最大收益。**


【贪心解法】

收集每天的正利润便可，代码如下：

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```


【动态规划】

1. $dp[i][0]$ 表示第i天持有股票所得现金。

   $dp[i][1]$ 表示第i天不持有股票所得现金。

2. 如果第i天持有股票即$dp[i][0]$， 那么可以由两个状态推出来

   * 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：$dp[i - 1][0]$
   * 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格即：$dp[i - 1][1] - prices[i]$
  
   如果第i天不持有股票即$dp[i][1]$， 也可以由两个状态推出来

   * 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：$dp[i - 1$][1]
   * 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：$prices[i] + dp[i - 1][0]$
     所以 $dp[i][1] = \max(dp[i - 1][1], prices[i] + dp[i - 1][0])$;

**推导 $dp[i][0]$** 

- 因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。
- 因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即 $dp[i][0]$ 一定就是 -prices[i]。

代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```




#### 123.买卖股票的最佳时机III

>给定⼀个数组，它的第 i 个元素是⼀⽀给定的股票在第 i 天的价格。
>设计⼀个算法来计算你所能获取的最⼤利润。你最多可以完成 两笔 交易。
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**最多买卖两次，问最大收益。**

【动态规划】

一天一共就有五个状态，

0. 没有操作
1. 第一次买入
2. 第一次卖出
3. 第二次买入
4. 第二次卖出

$dp[i][j]$中 i表示第i天，j为 [0 - 4] 五个状态，$dp[i][j]$ 表示第i天状态j所剩最大现金。


达到$dp[i][1]$ 状态，有两个具体操作：

* 操作一：第i天买入股票了，那么$dp[i][1] = dp[i-1][0] - prices[i]$
* 操作二：第i天没有操作，而是沿用前一天买入的状态，即：$dp[i][1] = dp[i - 1][1]$

$dp[i][1] = \max(dp[i-1][0] - prices[i], dp[i - 1][1])$;

同理$dp[i][2]$也有两个操作：

* 操作一：第i天卖出股票了，那么 $dp[i][2] = dp[i - 1][1] + prices[i]$
* 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：$dp[i][2] = dp[i - 1$][2]

所以$dp[i][2] = \max(dp[i - 1][1] + prices[i], dp[i - 1][2])$

同理可推出剩下状态部分：

$dp[i][3] = \max(dp[i - 1][3], dp[i - 1][2] - prices[i]);$
$dp[i][4] = \max(dp[i - 1][4], dp[i - 1][3] + prices[i]);$

代码如下：

```C++
// 版本一
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```



一种优化空间写法，对应的C++版本：

```C++
// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```



#### 188.买卖股票的最佳时机IV

> 给定⼀个整数数组 prices ，它的第 i 个元素 prices[i] 是⼀⽀给定的股票在第 i 天的价格。
> 设计⼀个算法来计算你所能获取的最⼤利润。你最多可以完成 k 笔交易。
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**最多买卖k笔交易，问最大收益。**

使用二维数组 dp[i][j] ：第i天的状态为v，所剩下的最大现金是dp[i][j]

j的状态表示为：

* 0 表示不操作
* 1 第一次买入
* 2 第一次卖出
* 3 第二次买入
* 4 第二次卖出
* .....

**除了0以外，偶数就是卖出，奇数就是买入**。


2. 确定递推公式

达到 $dp[i][1]$ 状态，有两个具体操作：

* 操作一：第i天买入股票了，那么 $dp[i][1] = dp[i - 1][0] - prices[i]$
* 操作二：第i天没有操作，而是沿用前一天买入的状态，即：$dp[i][1] = dp[i - 1][1]$

$dp[i][1] = \max(dp[i - 1][0] - prices[i], dp[i - 1][0]);$

同理dp[i][2]也有两个操作：

* 操作一：第i天卖出股票了，那么 $dp[i][2] = dp[i - 1][1] + prices[i]$
* 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：$dp[i][2] = dp[i - 1][2]$

$dp[i][2] = \max(dp[i - 1][i] + prices[i], dp[i][2])$

同理可以类比剩下的状态，代码如下：

```C++
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
```

整体代码如下：

```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

当然有的解法是定义一个三维数组$dp[i][j][k]$，第i天，第j次买卖，k表示买还是卖的状态，从定义上来讲是比较直观。但感觉三维数组操作起来有些麻烦，直接用二维数组来模拟三位数组的情况，代码看起来也清爽一些。

#### 309.最佳买卖股票时机含冷冻期 

> 给定⼀个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
> 设计⼀个算法计算出最⼤利润。在满⾜以下约束条件下，你可以尽可能地完成更多的交易（多次买卖⼀⽀股票）:
>
> - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> - 卖出股票后，你⽆法在第⼆天买⼊股票 (即冷冻期为 1 天)。

**可以多次买卖但每次卖出有冷冻期1天。**

相对于`122.买卖股票的最佳时机II` 本题加上了一个冷冻期。

在`122.买卖股票的最佳时机II` 中有两个状态，持有股票后的最多现金，和不持有股票的最多现金。

本题则可以花费为四个状态

$dp[i][j]$ ：第i天状态为j，所剩的最多现金为 $dp[i][j]$。

具体可以区分出如下四个状态：

* 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
* 卖出股票状态，这里就有两种卖出股票状态
  * 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
  * 状态三：今天卖出了股票
* 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！


达到买入股票状态（状态一）即：$dp[i][0]$，有两个具体操作：

* 操作一：前一天就是持有股票状态（状态一），$dp[i][0] = dp[i - 1][0]$
* 操作二：今天买入了，有两种情况
  * 前一天是冷冻期（状态四），$dp[i - 1][3] - prices[i]$
  * 前一天是保持卖出股票状态（状态二），$dp[i - 1][1] - prices[i]$

所以操作二取最大值，即：$\max(dp[i - 1][3], dp[i - 1][1]) - prices[i]$

那么$dp[i][0] = \max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);$

达到保持卖出股票状态（状态二）即：$dp[i][1]$，有两个具体操作：

* 操作一：前一天就是状态二
* 操作二：前一天是冷冻期（状态四）

$dp[i][1] = \max(dp[i - 1][1], dp[i - 1][3]);$

达到今天就卖出股票状态（状态三），即：$dp[i][2] $，只有一个操作：

* 操作一：昨天一定是买入股票状态（状态一），今天卖出

即：$dp[i][2] = dp[i - 1][0] + prices[i];$

达到冷冻期状态（状态四），即：$dp[i][3]$，只有一个操作：

* 操作一：昨天卖出了股票（状态三）

$dp[i][3] = dp[i - 1][2];$

综上分析，递推代码如下：

```C++
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i];
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

整体代码如下：

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(n)

#### 714.买卖股票的最佳时机含⼿续费

> 给定⼀个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；⾮负整数 fee 代表了交易股票的⼿续费⽤。
> 你可以⽆限次地完成交易，但是你每笔交易都需要付⼿续费。如果你已经购买了⼀个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最⼤值。
> 注意：这⾥的⼀笔交易指买⼊持有并卖出股票的整个过程，每笔交易你只需要为⽀付⼀次⼿续费。

**可以多次买卖，但每次有手续费。**


相对于`122.买卖股票的最佳时机II`，本题只需要在计算卖出操作的时候减去手续费就可以了，

唯一差别在于递推公式部分

这里重申一下dp数组的含义：

$dp[i][0] $表示第i天持有股票所省最多现金。
$dp[i][1]$ 表示第i天不持有股票所得最多现金

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```



### 打家劫舍系列

#### 198.打家劫舍

>你是⼀个专业的⼩偷，计划偷窃沿街的房屋。每间房内都藏有⼀定的现⾦，影响你偷窃的唯⼀制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同⼀晚上被⼩偷闯⼊，系统会⾃动报警。
>给定⼀个代表每个房屋存放⾦额的⾮负整数数组，计算你不触动警报装置的情况下 ，⼀夜之内能够偷窃到的最⾼⾦额。
>示例 1：
>输⼊：[1,2,3,1]
>输出：4
>解释：偷窃 1 号房屋 (⾦额 = 1) ，然后偷窃 3 号房屋 (⾦额 = 3)。
>偷窃到的最⾼⾦额 = 1 + 3 = 4 。
>示例 2：
>输⼊：[2,7,9,3,1]
>输出：12
>解释：偷窃 1 号房屋 (⾦额 = 2), 偷窃 3 号房屋 (⾦额 = 9)，接着偷窃 5 号房屋 (⾦额 = 1)。



1. dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的⾦额为dp[i]。

2. 决定dp[i]的因素就是第i房间偷还是不偷。

   dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);



#### 213.打家劫舍II

> 你是⼀个专业的⼩偷，计划偷窃沿街的房屋，每间房内都藏有⼀定的现⾦。这个地⽅所有的房屋都 **围成⼀圈** ，这意味着第⼀个房屋和最后⼀个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同⼀晚上被⼩偷闯⼊，系统会⾃动报警 。
> 给定⼀个代表每个房屋存放⾦额的⾮负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最⾼⾦额



1. 情况⼀：考虑不包含⾸尾元素
2. 情况⼆：考虑包含⾸元素，不包含尾元素
3. 情况三：考虑包含尾元素，不包含⾸元素

情况三怎么就包含了情况⼀了呢？ 本⽂图中最后⼀间房不能偷啊，偷了⼀定不是最优结果。

```cpp

// 注意注释中的情况⼆情况三，以及把198.打家劫舍的代码抽离出来了
class Solution {
public:
int rob(vector<int>& nums) {
if (nums.size() == 0) return 0;
if (nums.size() == 1) return nums[0];
int result1 = robRange(nums, 0, nums.size() - 2); // 情况⼆
int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
return max(result1, result2);
}
// 198.打家劫舍的逻辑
int robRange(vector<int>& nums, int start, int end) {
if (end == start) return nums[start];
vector<int> dp(nums.size());
dp[start] = nums[start];dp[start + 1] = max(nums[start], nums[start + 1]);
for (int i = start + 2; i <= end; i++) {
dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
}
return dp[end];
}
};
```



#### 337.打家劫舍 III

> 在上次打劫完⼀条街道之后和⼀圈房屋后，⼩偷⼜发现了⼀个新的可⾏窃的地区。这个地区只有⼀个⼊⼝，我们称之为“根”。 除了“根”之外，每栋房⼦有且只有⼀个“⽗“房⼦与之相连。⼀番侦察之后，聪明的⼩偷意识到“这个地⽅的所有房屋的排列类似于⼀棵⼆叉树”。 如果两个直接相连的房⼦在同⼀天晚上被打劫，房屋将⾃动报警。
> 计算在不触动警报的情况下，⼩偷⼀晚能够盗取的最⾼⾦额。

对于树的话，⾸先就要想到遍历⽅式，前中后序（深度优先搜索）还是层序遍历（⼴度优先搜索）。

**本题⼀定是要后序遍历，因为通过递归函数的返回值来做下⼀步计算。**

**记忆化递推**

```cpp
class Solution {
public:
unordered_map<TreeNode* , int> umap; // 记录计算过的结果
int rob(TreeNode* root) {
if (root == NULL) return 0;
if (root->left == NULL && root->right == NULL) return root->val;
if (umap[root]) return umap[root]; // 如果umap⾥已经有记录则直接返回
// 偷⽗节点
int val1 = root->val;
if (root->left) val1 += rob(root->left->left) + rob(root->left->right);
// 跳过root->leftif (root->right) val1 += rob(root->right->left) + rob(root->right-
>right); // 跳过root->right
// 不偷⽗节点
int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩⼦
umap[root] = max(val1, val2); // umap记录⼀下结果
return max(val1, val2);
}
};
时间复杂度：O(n)
空间复杂度：O(logn) 算上递推系统栈的空间
```



1. ⼀个节点 偷与不偷的两个状态所得到的⾦钱，那么返回值就是⼀个⻓度为2的数组。`vector<int> robTree(TreeNode* cur)`
   下标为0记录不偷该节点所得到的的最⼤⾦钱，下标为1记录偷该节点所得到的的最⼤⾦钱。

2. ⾸先明确的是使⽤后序遍历。 因为通过递归函数的返回值来做下⼀步计算。
   通过递归左节点，得到左节点偷与不偷的⾦钱。
   通过递归右节点，得到右节点偷与不偷的⾦钱。

3. ```s
   vector<int> left = robTree(cur->left); // 左
   vector<int> right = robTree(cur->right); // 右
   // 偷cur
   int val1 = cur->val + left[0] + right[0];
   // 不偷cur
   int val2 = max(left[0], left[1]) + max(right[0], right[1]);
   return {val2, val1};
   ```



### 回文

#### 647. 回⽂⼦串

> 给定⼀个字符串，你的任务是计算这个字符串中有多少个回⽂⼦串。
> 具有不同开始位置或结束位置的⼦串，即使是由相同的字符组成，也会被视作不同的⼦串。

`动态规划`

1. 布尔类型的 $dp[i][j]$ ：表示区间范围[i,j] （注意是左闭右闭）的⼦串是否是回⽂⼦串，如果是 $dp[i][j]$ 为true，否则为false。

2. ```cpp
   if (s[i] == s[j]) {
   	if (j - i <= 1) { // 情况⼀ 和 情况⼆
   		result++;
   		dp[i][j] = true;
   	} else if (dp[i + 1][j - 1]) { // 情况三
   		result++;
   		dp[i][j] = true;
   	}
   }
   ```

   

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int ans = 0, n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        for (int d = 0; d < n; d++) {
            for (int i = 0; i + d < n; i++) {
                int j = i + d;
                if (s[i] != s[j]) continue;
                if (d == 0 || d == 1) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
                if (dp[i][j]) ans++;
            }
        }
        return ans;
    }
};
```



`双指针法`

⾸先确定回⽂串，就是找中⼼然后想两边扩散看是不是对称

在遍历中⼼点的时候，⼀个元素可以作为中⼼点，两个元素也可以作为中⼼点。



```cpp
int countSubstrings(string s) {
    int count = 0;
    for (int i = 0; i < s.length(); ++i) {
        count += extendSubstrings(s, i, i); // 奇数长度
        count += extendSubstrings(s, i, i + 1); // 偶数长度
    }
    return count;
}
int extendSubstrings(string s, int l, int r) {
    int count = 0;
    while (l >= 0 && r < s.length() && s[l] == s[r]) {
        --l;
        ++r;
        ++count;
    }
    return count;
}
```





#### 516.最⻓回⽂⼦序列

> 给定⼀个字符串 s ，找到其中最⻓的回⽂⼦序列，并返回该序列的⻓度。可以假设 s 的最⼤⻓度为 1000



1. $dp[i][j]$ ：字符串s在[i, j]范围内最⻓的回⽂⼦序列的⻓度为 $dp[i][j]$。

2. ```cpp
   if (s[i] == s[j]) {
   	dp[i][j] = dp[i + 1][j - 1] + 2;
   } else {
   	dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
   }
   ```

   





## 分而治之（divide-and-conquer）

把一个问题划分成若干较小的子问题（通常具有相同或相关的类型，理想情况下规模也大致一样），然后各个击破，最后在必要时把子问题的解组合起来，就得到了原始问题的解。

分治算法每一步需要解决多个子问题，而减治算法则仅需要解决一个。

分治问题由“分”(divide)和“治”(conquer)两部分组成,通过把原问题分为子问题,再将子问题进行处理合并,从而实现对原问题的求解。归并排序就是典型的分治问题

分治法

1. 将问题 “ 分割 ” 成局部问题 。（ Divide )

2. 递归地求解局部问题 。（ Solve )

3. 将局部问题的解 “ 整合 ” ， 解决原问题 。（ Conquer )

> 定义 T(n) 表示处理一个长度为 n 的数组的时间复杂度,则归并排序的时间复杂度递推公式为 T(n) = 2T(n/2) + O(n)。其中 2T(n/2) 表示我们分成了两个长度减半的子问题,O(n) 则为合并两个长度为 n/2 数组的时间复杂度。

那么怎么利用这个递推公式得到最终的时间复杂度呢?这里我们可以利用著名的主定理
(Master theorem)求解:
定理 8.1. 主定理
考虑 $T(n) = aT(n/b) + f (n)$,定义 $k = \log_ba$

1. 如果$ f (n) = O(n^p ) $ 且 $p < k$，那么 $T(n) = O(n^K )$
2. 如果存在 $c ≥ 0$ 满足 $f (n) = O(n^k \log^cn)$,那么 $T(n) = O(n^k \log^{c+1}n)$
3. 如果 $f (n) = O(n^p )$ 且 $p > k$,那么 $T(n) = O( f (n))$

通过主定理我们可以知道,归并排序属于第二种情况,且时间复杂度为 O(n log n)。其他的分治问题也可以通过主定理求得时间复杂度。
自上而下的分治可以和 memoization 结合,避免重复遍历相同的子问题。如果方便推导,也可以换用自下而上的动态规划方法求解。

### 表达式问题



#### [241.为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/description/)

> 给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 `+`, `-` 以及 `*` 。
>
> **示例 1:**
>
> ```cpp
> 输入: "2-1-1"
> 输出: [0, 2]
> 解释: 
> ((2-1)-1) = 0 
> (2-(1-1)) = 2
> ```



```cpp
class Solution {
public:
    vector<int> diffWaysToCompute(string expression) {
        if (expression.empty()) return {};
        vector<int> ways;
        for (int i = 0; i < expression.length(); i++) {
            if (expression[i] == '+' || expression[i] == '-' || expression[i] == '*') {
                vector<int> left = diffWaysToCompute(expression.substr(0, i));
                vector<int> right = diffWaysToCompute(expression.substr(i + 1, expression.length() - i - 1));
                for (const int &l : left) {
                    for (const int &r : right) {
                        switch (expression[i]) {
                            case '+' : ways.push_back(l + r); break;
                            case '-' : ways.push_back(l - r); break;
                            case '*' : ways.push_back(l * r); break;
                        }
                    }
                }
            }
        }
        if (ways.empty()) ways.push_back(stoi(expression));
        return ways;
    }
};
// @lc code=end

```

932. Beautiful Array (Medium)
试着用从上到下的分治(递归)写法求解,最好加上 memoization;再用从下到上的动态规
划写法求解。
进阶难度
312. Burst Balloons (Hard)
试着用从上到下的分治(递归)写法求解,最好加上 memoization;再用从下到上的动态规
划写法求解。



### 减而治之（decrease-and-conquer）

在从给定问题的解及其较小规模谜面的解之间找到某种关系。一旦找到，这样的关系就可以自然曲然地导向某种递归算法(recursivealgonthm），它可以将问题减少为一系列的、规模越来越小的谜面，直至可以一下子解决为止。

通过自底而上的方法来发掘较大和较小问题之间的关系，
先把谜题的最小规模谜血解出，然后再看第二小的，依此类推。这种方法有时称为增量法（incremental approach)

### 变而治之（transform-and-conquer)

思想基础是变换。问题的求解分为两个阶段。首先是变换阶段，某个问题被修改或变换成另一个问题，出于某种理由，修改或变换后的问题较容易求解

三种变体

1. 谜面简化（instance simplification），即首先将问题的一个谜面变换成同样问题的另一个谜面，而该谜面具备某种特殊性使得问题较易求解，
2. 变更（representationchange），把问题的输入变换成另一种表示，从而更有助于找到有效算法来求解。
3. 问题归约(problemreducuon)，即把给定问题的谜面整体转化为另一个问题的谜面



### 迭代改进 （iterative improvement）

贪心算法是一块块地将解拼凑出来的，而迭代改进算法则是从易得的估计解出发，并重复地应用同样的简单步骤不断地改进估计解

要验证这种算法，就需要确认存疑的算法是否真的可以在有穷步内终止，最终得到的估计解是否真的解决了问题。

只存在有限个值，这就保证了在有限步以后算法必会中止得到最终值以后，问题得解。
这种特质称为单变性（monovariant）。寻找适当的单变性是需要技巧的任务。



# 数学问题

### 公倍数与公因数

辗转相除法：最大公因数(greatest common divisor, gcd)，到最小公倍数(least common multiple,)。

$\gcd(a, b)$ 自然数 a 和 b 的最大公约数的函数

因为 $a = b \times p + q$， 所以 $\gcd(b, q)$ 既整除 a 又整除b,也就整除 $\gcd(a,b)$ 的。

反之，$q = a - b \times p$，同理可证 $\gcd(b, q)$ 整除 $\gcd(a,b)$ 的。


```cpp
int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a% b);
}
int lcm(int a, int b) {
	return a * b / gcd(a, b);
}

```

扩展欧几里得算法(extended gcd)在求得 a 和 b 最大公因数的同时,也得到它们的系数 x 和 y,从而使 $ax + by = \gcd(a, b)$。

假设已经求得 $bx' + (a\%b)y' = \gcd(a,b)$ 的整数解 $x'y'$。再将
$a\%b = a - (a/b)\times b$ 代入后就得到 $ay'+ b(x' - (a/b)\times y') = \gcd(a,b)$
而当 $b=0$ 时则有，$a \times 1 + b\times 0 = \gcd(a,b)$



```cpp
int xGCD(int a, int b, int &x, int &y) {
	if (!b) {
		x = 1, y = 0;
		return a;
	}
	int x1, y1, gcd = xGCD(b, a % b, x1, y1);
	x = y1, y = x1 - (a / b) * y1;
	return gcd;
}

```

### 质数

> 质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。



> 204. Count Primes (Easy)
>
> 给定一个数字 n,求小于 n 的质数的个数。

埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）

![埃氏筛详解](/Image/B1.算法设计-photo/20190109171010273.gif)





```cpp
class Solution {
public:
    int countPrimes(int n) {
        if (n <= 2) return 0;
        vector<bool> prime(n + 5, true);
        int i = 3, sn = sqrt(n);
        int count = n / 2;
        while (i <= sn) {
            for (int j = i * i; j < n; j += 2 * i) {
                if (prime[j]) {
                    prime[j] = false;
                    --count;
                }
            }
            do { i += 2; } while (i <= sn && prime[i] == false);
        }
        return count;
    }
};
```



线性筛

关键：$N = M * p\\ M是最大的因子，p是最小的素因子\\p一定要小于等于M的最小素因子$

如果需要`is_prime = { 1, 1, 0};`

```cpp
#include<iostream>
using namespace std;

const int max_n = 200000;

int prime[max_n + 5] = {0};

int main() {
    for (int i = 2; i <= max_n; i++) {    //N= M*P， i记录M，最大素因子
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0]; ++j) {
            if (i * prime[j] > max_n) break;
            prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;   //P只可以<=M的最小素因子；
        }
    }
    cout << prime[10001] << endl;
    return 0;
}
```









#### [172.阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/)

> 给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。
>
> 提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`



+ 为避免溢出使用更大数据范围的`long long`数据类型。使用乘法/加法更加符合直觉。当出现溢出时，不妨考虑除法/减法。

  ```cpp
  int trailingZeroes(int n) {
  	return n == 0? 0: n / 5 + trailingZeroes(n / 5);
  }
  
  class Solution {
      public:
        int trailingZeroes(int n) {
            long long div = 5;
            int cnt=0; 
            while(div <= n) { 
                cnt += n/div;
                div*=5;   // 溢出防范
            }
            return cnt;
        }-+
     };
  ```

  但是换用除法，就可以直接避免这个问题。

  ```cpp
      int trailingZeroes(int n) {
          int cnt=0; 
          while(n >0) { 
              cnt += n/5;
              n /=5;
          }
  
      return cnt;
      }
  ```

  



### 快速幂

对于快速幂中数据溢出的问题，有两种解决方法：

1. 方法一：对于两个数 x y，现在想求 `x * y % MOD`，可以将 x 表示成 `a * DIGS + b`，y 表示成 `c * DIGS + d，x * y % MOD` 则等价与 `( a * c * DIGS2 + a * d * DIGS + b * c * DIGS + b * d ) % MOD （ DIGS = 10^5 ）`。 这样进行分解后就可以有效的避免数据溢出。
2. 方法二：对于快速幂中的乘法，我们可以写个与快速幂类似的快速乘法，在快速乘法的过程中不断取模来保持数据在范围之内。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const long long MOD = 10000000000;
const long long DIGS = 100000;

long long Multi(long long x, long long y) {
    long long a, b, c, d, ans = 0;
    a = x / DIGS; b = x % DIGS;
    c = y / DIGS; d = y % DIGS;
    ans = (ans + ((a * d % MOD * DIGS)) % MOD) % MOD;
    ans = (ans + ((b * c % MOD * DIGS)) % MOD) % MOD;
    ans = (ans + (b * d % MOD)) % MOD;
    return ans;
}

long long quick_pow(long long a, long long b) {
    long long ans = 1;
    while (b > 0) {
        if (b & 1) {
            ans = Multi(ans, a);
        }
        a = Multi(a, a);   //直接a * a会溢出
        b = b >> 1;
    }
    return ans;
}

int64_t quick_multi(int64_t a , int64_t b , int64_t mod) {
    int64_t ret = 0;
    while (b) {
        if (b & 1)  ret = (ret + a) % mod;
        a = (a << 1) % mod;
        b >>= 1;
    }
    return ret % mod;
}


int main() {
    long long ans = 0;
    for (int i = 1; i <= 1000; ++i) {
        if (i % 10 == 0) continue;
        ans += quick_pow(i, i);
        ans %= MOD;
    }
    cout << ans << endl;
    return 0;
}
```





#### [326.3的幂](https://leetcode-cn.com/problems/power-of-three/description/)

> 判断一个数字是否是 3 的次方。



```cpp
有两种方法,一种是利用对数。设 log3 n = m,如果 n 是 3 的整数次方,那么 m 一定是整数。
bool isPowerOfThree(int n) {
	return fmod(log10(n) / log10(3), 1) == 0;
}
因为在 int 范围内 3 的最大次方是 319 = 1162261467,如果 n 是 3 的整数次方,那么1162261467 除以 n 的余数一定是零;反之亦然。
bool isPowerOfThree(int n) {
	return n > 0 && 1162261467 % n == 0;
}

```



### 随机与取样

#### [384.打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/description/)

> 给定一个数组,要求实现两个指令函数。第一个函数“shuffle”可以随机打乱这个数组,第二个函数“reset”可以恢复原来的顺序。
>
> 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
>
> 实现 `Solution` class:
>
> - `Solution(int[] nums)` 使用整数数组 `nums` 初始化对象
> - `int[] reset()` 重设数组到它的初始状态并返回
> - `int[] shuffle()` 返回数组随机打乱后的结果

 Fisher-Yates 洗牌算法,原理是通过随机交换位置来实现随机打乱,有正向和反向两种写法,

```cpp
class Solution {
private : 
vector<int> origin;
public:
    Solution(vector<int>& nums) : origin(std::move(nums)) {

    }
    
    vector<int> reset() {
        return origin;
    }
    
    vector<int> shuffle() {
        if (origin.empty()) return {};
        vector<int> shuffled(origin);
        int n = shuffled.size();
        // 反向洗牌:
        for (int i = n - 1; i >= 0; i--) {
            swap(shuffled[i], shuffled[rand() % (i + 1)]);
        }
        // 正向洗牌:
        /*
        for (int i = 0; i < n; i++) {
            int pos = rand() % (n - i);
            swap(shuffled[i], shuffled[i + pos]);
        }
        */
       return shuffled;
    }
};
```





## 数据结构



## 



# 数据结构

## 单调栈

单调栈通过维持栈内值的单调递增（递减）性



> 请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
>
> **示例 1:**
>
> ```cpp
> 输入: temperatures = [73,74,75,71,69,72,76,73]
> 输出: [1,1,4,2,1,1,0,0]
> ```

#### [739.每日温度](https://leetcode-cn.com/problems/daily-temperatures/description/)

维持一个单调递减的栈，表示每天的温度；对于每个日期 p，如果 p 的温度比栈顶存储位置 q 的温度高，则我们取出 q，并记录 q 需要等待的天数为 p − q；

```cpp
 class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int size = temperatures.size();
        vector<int> ans(size, 0);
        stack<int> indices;
        for (int i = 0; i < size; ++i) {
            while (!indices.empty()) {
                int pre_index = indices.top();
                if (temperatures[i] <= temperatures[pre_index]) {
                    break;
                }
                indices.pop();
                ans[pre_index] = i - pre_index;
            }
            indices.push(i);
        }
        return ans;
    }
};
```

## 优先队列

#### [23.合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/description/)

把所有的链表存储在一个优先队列中，每次提取所有链表头部节点值最小的那个节点，直到所有链表都被提取完为止。

```cpp
 /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        //return merge(lists, 0, lists.size() - 1);
        std::function<bool(const ListNode *, const ListNode *)> cmp = [](const ListNode *a, const ListNode *b)->bool {
            return a->val > b->val;
        };
        priority_queue<ListNode *, vector<ListNode *>, decltype(cmp)> heap(cmp);
        for (auto cur : lists) {
            if (cur) heap.push(cur);
        }
        ListNode dummy(0), *p = &dummy;
        while (!heap.empty()) {
            auto cur = heap.top();
            heap.pop();
            p->next = cur;
            p = cur;
            if (cur->next) heap.push(cur->next);
        }
        p->next = nullptr;
        return dummy.next;

    }
private :
    ListNode* merge(vector<ListNode*>& lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode dummy, *p = &dummy;
        dummy.next = nullptr;
        while (l1 || l2) {
            if (!l2 || l1 && l1->val < l2->val) {
                p->next = l1;
                p = p->next;
                l1 = l1->next;
            } else {
                p->next = l2;
                p = p->next;
                l2 = l2->next;
            }
        }
        return dummy.next;
    }
};
```





## [239] 滑动窗口最大值



```cpp
/*
 * @lc app=leetcode.cn id=239 lang=cpp
 *
 * [239] 滑动窗口最大值
 */

// @lc code=start
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q;
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i) {
            while(!q.empty() && nums[i] >= nums[q.back()]) q.pop_back();
            q.push_back(i);
            if (i < k - 1) continue;
            if (q.front() + k == i) q.pop_front();
            res.push_back(nums[q.front()]);
        }
        return res;
    }
};
// @lc code=end

```



## 总结

### 常



## 掌握动态规划

### 旅行商问题

> 给定一个 n 个顶点组成的带权有向图的距离矩阵成 $d(I,j)$ ( INF 表示没有边 )。 要求从顶点 0 出发 ,经过每个顶点恰好一次后再回到顶点 0。 问所经过的边的总权重的最小值是多少?

著名的旅行商问题(TSP, Traveling Salesman Problem )。 TSP 问题是 NP 困难的,没有已知的多项式时间的高效算法可以解决这一问题。

所有可能的路线共有 $(n-1)!$ 种

假设现在已经访问过的顶点的集合为 $S$，当前所在的顶点为 $V$，用办 $dp[S][v]$  表示从 $v$ 出发访问剩余的所有顶点,最终回到顶点 $0$ 的路径的权重总和的最小值。由从 $v$ 出发可以移动到任意的一个节点 $u \notin S$
$$
dp[V][0] = 0 \\
dp[S][v] = min\{dp[S \cup {u}][u] + d(v,u) \big| u \notin S \}
$$


### 矩阵的幂





### 利用数据结构高效求解




## 计算几何

## 数学问题

### 矩阵

#### 1.线性方程组 

### 模运算的世界

#### 1. 逆元 

如何求解线性同余方程

#### 2. 费马小定理





### 计数

#### 容斥原理

> 给定 $a_1, a_2, \cdots, a_m$，求 $1$ 到 $n$ 中的整数至少能整除 $a$ 中的一个元素的数有几个。


此问题即是求容斥原理的公式，计算方法为：累加所有能整除一个元素的个数，减去所有两个元素的公倍数



```cpp
typedef long long ll;
int a[MAX_N];
int n,m;
 
void solve(){
	ll res=0;
	//变量m个元素的所有子集
	for(int i=0;i<(1<<m);i++){
		int num=0;
		for(int j=i;j!=0;j>>=1 )num += j&1;//统计该子集有多少个元素
		ll lcm=1;
		for(int j=0;j<m;j++){//根据二进制中1的位置判断哪个元素出现
			if(i>>j&1){
				lcm=lcm/gcd([lcm,a[j]])*a[j];//求一个数组的最小公倍数		
				if(lcm>n) break;
			}
		}
		if(num%2==0) res-=n/lcm;
		else res+=n/lcm;
	}
	printf("%d\n”,res);
}
```

#### 莫比乌斯函数



### 具有对称性的计数

### Polya计数定理





## 游戏的必胜策略

### 游戏与必胜策略

#### 1.硬币游戏1








## 常用技巧精选 

###  




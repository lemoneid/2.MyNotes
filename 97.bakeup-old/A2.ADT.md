---
id : A2.ADT
title : A2.ADT
typora-root-url : ../
---

## 字符串

字符串在计算机中的应用非常广泛，这里讨论有关字符串的最重要的算法：

* 排序
* 查找
  * 单词查找树
  * 子串查找
* 正则表达式:正则表达式是模式匹配的基础,是一个一般化了的子字符串的查找问题,也是搜索工具grep的核心。
  * 模式匹配
  * grep
* 数据压缩
  * 赫夫曼树
  * 游程编码





# 链表

* 链表
* 双向链表
* 双向循环链表

## 链表

这个就不介绍了。重点说下双向链表。


### 扩缩容

简单说下编程语言 java， golang中 LinkList的扩缩容的策略。

java 中扩容，每次扩容新增原先容量的 1/2

```
 int newCapacity = oldCapacity + (oldCapacity >> 1);
```


## 双向链表

双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

双向链表克服了单链表中访问某个节点前驱节点(插入，删除操作时)，只能从头遍历的问题。

```
typedef int Value
typedef struct Entry{
	struct Entry *next,*prev;
	Value value;
}DoubleLink;

```

## 循环链表

最后一个节点指针指向头节点的链表


## 双向循环链表







# skip-list

skip-list 跳表。 redis 中的 sset(有序集合) 使用跳表来实现，为什么不是用红黑树，而是跳表实现sset，带着这样的疑问，有了本文。













### 暴力法(brute force)

大整数计算$a^n \ mod \ m = \underbrace { a \times a \cdots \times a} _n \ mod\  m$

#### 选择排序

$$
\begin{aligned}
A_0 \le A_1 \le \cdots \le A_{i-1} &| A_i,\dots,A_{min},A_{n-1}\\
已经排好序&|交换A_{min}与A_i\\
C(n) = \sum_{i = 0}^{n - 2} \sum_{j = i+1}^{n - 1} &= \frac{(n-1)n}{2}
\end{aligned}
$$

#### 冒泡排序

$$
\begin{aligned}
A_0,\dots,A_j,\bigvee ,A_{j+1},\cdots,A_{n- i +1}&| A_{n - i} \le \cdots \le A_{n-1} \\
如果A_j与A_{j+1}逆序就交换&|已经排好序\\
C(n) = \sum_{i = 0}^{n - 2} \sum_{j = 0}^{n- 2- i} &= \frac{(n-1)n}{2}
\end{aligned}
$$



#### 顺序查找

#### 暴力字符串匹配

### 减治法(decrease-conquer)

或称为增量法(increment approach)

3种变化形式

1. 减去一个常量:每次迭代减1
2. 减去一个常量因子:每次迭代减半
3. 减去的规模是可变的:$gcd(m,n)=gcd(n, m \ mod \ n)$

#### 插入排序

$$
\begin{aligned}
A_0 \le \cdots \le A_j \ |& \lt A_{j+1}\le \cdots \le A[i]\cdots A_{n-1}\\
小于等于A_i\ |&\ 大于A_i
\end{aligned}
$$



#### ==希尔排序==



#### 拓扑排序

在有向图中:是否可以按照某种次序列出顶点,使得任意一条边的起点在终点之前

$有向图没有回路=拓扑排序有解$

求解拓扑排序

1. 深搜
2. 减常量:不断在剩余有向图中求解一个入度为0的源(source)



#### 生成组合对象

##### 生成排列

对n个元素的集合$\{a_1,\cdots,a_n\}$的下标,生成$\{1,\cdots,n\}$所有$n!$排列的问题

减一法:生成所有$(n-1)!$的排列,将n插入到n-1个元素的所有排列中








# 算法问题



### 最大公约数

#### 欧几里得算法

$$
gcd(m, n) = gcd(n, m \ mod \ n)
$$

拓展欧几里得:$gcd(m, n) = d \to mx + ny = d$

带锁的门:因数个数的奇偶性





### 排序问题

1. 稳定性:保证两个键值相同的元素,维持相对顺序
2. 额外存储空间



### 查找问题

1. 顺序查找
2. 二分查找->应用受限
3. 将原集合用另一种形式表示->大型数据库的存取



### 字符串处理问题

1. 字符串匹配



### 图问题

图:若干相连的节点构成的集合

1. 遍历算法:一次访问所有节点
2. 最短路径算法:另个节点见得最短路径
3. 有向图的拓扑排序



1. 旅行商问题:找出访问n个城市的最短路径,并保证每个城市只访问一次
2. 图填色问题:最少种类的颜色为图的顶点填色,并保证以边相连的两个顶点颜色不同



### 组合问题

1. 随问题规模的增大,组合对象的数量增长极快
2. 绝大多数问题没有一种可接受时间的算法



### 几何问题

处理点,线,多面体等几何对象



1. 最近对问题:给定平面上n个点中,求最近的两个点
2. 凸包问题:求一个能把给定集合中所有点包含在内的最小凸多边形



### 数值问题

1. 具有连续性的数学问题:解方程和方程组,计算定积分,求函数的值,
   - 一方面:问题本身只能近似求解
   - 另一方面:计算机对浮点数只能近似表示





# 数据结构

### 最重要的DataStructure

1. 数组:用于实现字符串,二进制串
2. 链表:节点(头结点)+指针,双链表

用来封装更抽象的ADT

### 线性数据结构

1. 栈
2. 队列
3. 优先队列:有序数组,堆来实现

### 图

图:若干相连的节点构成的集合 

#### 基础定义

$$
\begin{aligned}
&G =<V,E>\\
&有限集合V:顶点(vertex); \\
&有限集合E:边(edge);\\
&顶点对(u,v):u与v为边(u,v)的端点(endpoint);u和v相互邻接(adjacent)\\
&有向边:顶点对(u,v)不等同于(v,u); u \to v : u为尾,v尾头\\
&有向图(digraph):所有边有向\\
&无向图(undirected \ graph):所有边无向\\
&完全图(complete):任意两个顶点相连,K_{|V|}, |E| = \frac {|V| \times (|V| - 1)}{2}\\
&稠密图(dense):\\
&稀疏图(sparse):
&边的权重或成本:有向边的值
\end{aligned}
$$

#### 图的表示

1. 邻接矩阵(adjacent matrix)
   $$
   Edge =
   \begin{matrix}
   \quad  & a & b & c & d\\
   a & 0  & 1 & 0 & 1\\
   b & 1 & 0 &  0 & 0\\
   c & 0 & 0 &  0 & 1\\
   d & 1 & 0 & 1 & 0\\
   \end{matrix}
   $$

2. 邻接表(list)
   $$
   \begin{aligned}
   &[a] \to  b \to d\\
   &[b] \to a\\
   &[c  \to d\\
   &[d] \to a \to c
   \end{aligned}
   $$

#### 路径和环

**序列**:图G中,始于u,止于v的邻接

**简单路径**:路径上所有顶点不同

**连通**:图G中任意一对(u,v)都有从u到v的路径

**连通分量**:非连通图中,极大连通子图



### 树

#### 基础知识

**树**:连通无回路图

**祖先**:从根(root)到v的简单路径上的所有顶点为v的祖先

**深度**:从根到v的简单路径的长度

**树的高度**:从根到叶节点的最长简单路径的长度,最大深度



### 集合与字典

**集合**(set):互不相同项的无序组合



